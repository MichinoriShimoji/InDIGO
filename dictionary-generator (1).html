<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InDIGO - Interactive Dictionary Generation Optimizer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif; 
            background: linear-gradient(135deg, #0d1b4c 0%, #1a237e 50%, #283593 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #0d1b4c 0%, #1a237e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        header h1 { font-size: 24px; margin-bottom: 8px; }
        header p { opacity: 0.8; font-size: 14px; }
        
        .section {
            padding: 25px 30px;
            border-bottom: 1px solid #e9ecef;
        }
        .section h2 {
            font-size: 16px;
            color: #1a1a2e;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .section h2 .step {
            background: #3949ab;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .drop-zone {
            border: 2px dashed #3949ab;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8f9ff;
        }
        .drop-zone:hover { background: #eef0ff; border-color: #5a6fd6; }
        .drop-zone.dragover { background: #e0e5ff; border-color: #4a5fc6; }
        .drop-zone-icon { font-size: 48px; margin-bottom: 10px; }
        .drop-zone-text { color: #3949ab; font-size: 14px; }
        .drop-zone-text small { color: #6c757d; }
        
        #fileInput { display: none; }
        
        .loaded-files {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .file-tag {
            padding: 6px 12px;
            background: #d4edda;
            border: 1px solid #28a745;
            border-radius: 20px;
            font-size: 12px;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .file-tag .count {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
        }
        .file-tag .remove {
            cursor: pointer;
            color: #dc3545;
            font-weight: bold;
            margin-left: 4px;
        }
        .file-tag.csv-file {
            background: #cce5ff;
            border-color: #0d6efd;
            color: #004085;
        }
        .file-tag.csv-file .count {
            background: #0d6efd;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            font-size: 13px;
            color: #495057;
            margin-bottom: 6px;
        }
        .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
        }
        .input-group input:focus { outline: none; border-color: #3949ab; }
        .input-group small {
            display: block;
            margin-top: 6px;
            color: #6c757d;
            font-size: 12px;
        }
        
        .stats-box {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .stats-box h3 {
            font-size: 13px;
            color: #495057;
            margin-bottom: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #3949ab;
        }
        .stat-label {
            font-size: 11px;
            color: #6c757d;
        }
        
        .btn-generate {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-generate:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102,126,234,0.4); }
        .btn-generate:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .output-section {
            display: none;
            padding: 25px 30px;
            background: #d4edda;
        }
        .output-section.show { display: block; }
        .output-section h2 {
            color: #155724;
            margin-bottom: 15px;
        }
        .btn-download {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 28px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
        }
        .btn-download:hover { background: #218838; }
        
        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 15px;
            margin-top: 15px;
            font-size: 13px;
            color: #856404;
        }
        
        .debug-box {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .debug-box h3 {
            font-size: 13px;
            color: #0c5460;
            margin-bottom: 10px;
        }
        .debug-box pre {
            font-size: 11px;
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .tier-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        .tier-grid .input-group {
            margin-bottom: 0;
        }
        .tier-grid input {
            padding: 8px 12px;
            font-size: 13px;
        }
        
        .btn-reload {
            padding: 10px 20px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-reload:hover {
            background: #138496;
        }
        
        .audio-url-item {
            margin-bottom: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .audio-url-item label {
            display: block;
            font-size: 13px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 6px;
        }
        .audio-url-item input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 13px;
            font-family: monospace;
        }
        .audio-url-item input:focus {
            outline: none;
            border-color: #3949ab;
        }
        .audio-url-item input::placeholder {
            color: #adb5bd;
            font-size: 12px;
        }
        
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .tier-config-item {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3949ab;
        }
        .tier-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .tier-config-header strong {
            font-size: 14px;
            color: #1a1a2e;
        }
        .tier-config-count {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
        }
        .tier-config-count.zero {
            color: #dc3545;
        }
        .tier-info-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        .tier-info-tag {
            font-size: 10px;
            padding: 2px 6px;
            background: #e9ecef;
            border-radius: 3px;
            color: #495057;
        }
        .tier-info-more {
            font-size: 10px;
            padding: 2px 6px;
            color: #6c757d;
        }
        .tier-config-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        .tier-select {
            display: flex;
            flex-direction: column;
        }
        .tier-select label {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 3px;
        }
        .tier-select select {
            padding: 6px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
            background: white;
        }
        .tier-select select:focus {
            outline: none;
            border-color: #3949ab;
        }
        
        @media (max-width: 600px) {
            .tier-config-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        footer {
            padding: 20px 30px;
            text-align: center;
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî∑ InDIGO</h1>
            <p>Interactive Dictionary Generation Optimizer</p>
        </header>
        
        <!-- Step 1: „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ -->
        <div class="section">
            <h2><span class="step">1</span> EAF/JSON/CSV„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ</h2>
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-icon">üìÅ</div>
                <div class="drop-zone-text">
                    „Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó<br>
                    <small>„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏ÊäûÔºà.eaf, .json, .csv Ë§áÊï∞ÂèØÔºâ</small>
                </div>
            </div>
            <input type="file" id="fileInput" accept=".eaf,.EAF,.json,.csv,.CSV" multiple>
            <div class="loaded-files" id="loadedFiles"></div>
            
            <!-- „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†± -->
            <div class="debug-box" id="debugBox" style="display:none;">
                <h3>üîç EAFÊßãÈÄ†</h3>
                <pre id="debugInfo"></pre>
            </div>
            
            <div class="stats-box" id="statsBox" style="display:none;">
                <h3>üìä Ë™≠„ÅøËæº„ÅøÁµêÊûú</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="statFiles">0</div>
                        <div class="stat-label">„Éï„Ç°„Ç§„É´</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSentences">0</div>
                        <div class="stat-label">Êñá</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statEntries">0</div>
                        <div class="stat-label">Ë¶ãÂá∫„ÅóË™û</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Step 1.5: TierË®≠ÂÆö -->
        <div class="section" id="tierSection" style="display:none;">
            <h2><span class="step">1.5</span> TierÂêç„ÇíË®≠ÂÆö</h2>
            <p style="font-size:13px; color:#6c757d; margin-bottom:15px;">ÂêÑ„Éï„Ç°„Ç§„É´„ÅÆTierÊßãÈÄ†„ÅåÁï∞„Å™„ÇãÂ†¥Âêà„ÅØÂÄãÂà•„Å´Ë®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
            <div id="tierConfigList"></div>
            <button class="btn-reload" id="btnReload">üîÑ TierË®≠ÂÆö„ÇíÂèçÊò†„Åó„Å¶ÂÜçË™≠„ÅøËæº„Åø</button>
        </div>
        
        <!-- Step 2: Èü≥Â£∞URLË®≠ÂÆö -->
        <div class="section" id="audioSection" style="display:none;">
            <h2><span class="step">2</span> Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅÆURL„ÇíË®≠ÂÆö</h2>
            <p style="font-size:13px; color:#6c757d; margin-bottom:15px;">ÂêÑEAF„Éï„Ç°„Ç§„É´„Å´ÂØæÂøú„Åô„ÇãÈü≥Â£∞„Éï„Ç°„Ç§„É´„ÅÆURL„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàZenodoÁ≠âÔºâ</p>
            <div id="audioUrlList"></div>
            <div class="info-box" style="margin-top:10px;">
                üí° Zenodo„ÅÆÂ†¥Âêà: <code>https://zenodo.org/records/„É¨„Ç≥„Éº„ÉâID/files/„Éï„Ç°„Ç§„É´Âêç.wav?download=1</code>
            </div>
        </div>
        
        <!-- Step 3: ËæûÊõ∏ÊÉÖÂ†± -->
        <div class="section">
            <h2><span class="step">3</span> ËæûÊõ∏„ÅÆÊÉÖÂ†±Ôºà‰ªªÊÑèÔºâ</h2>
            <div class="input-group">
                <label>ËæûÊõ∏„Çø„Ç§„Éà„É´</label>
                <input type="text" id="titleInput" placeholder="ÂÆÆÂè§Ë™ûËæûÊõ∏" value="ÂÆÆÂè§Ë™ûËæûÊõ∏">
            </div>
            <div class="input-group">
                <label>„Çµ„Éñ„Çø„Ç§„Éà„É´</label>
                <input type="text" id="subtitleInput" placeholder="Miyako Language Dictionary" value="Miyako Language Dictionary">
            </div>
        </div>
        
        <!-- Step 4: ÁîüÊàê -->
        <div class="section">
            <h2><span class="step">4</span> HTML„ÇíÁîüÊàê</h2>
            <button class="btn-generate" id="btnGenerate" disabled>
                üìÑ ËæûÊõ∏HTML„ÇíÁîüÊàê
            </button>
            <div class="info-box">
                üí° ÁîüÊàê„Åï„Çå„ÅüHTML„Éï„Ç°„Ç§„É´„ÇíGitHub Pages„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åô„Çã„Å†„Åë„ÅßËæûÊõ∏„ÅåÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ
            </div>
        </div>
        
        <!-- Output -->
        <div class="output-section" id="outputSection">
            <h2>‚úÖ ÁîüÊàêÂÆå‰∫ÜÔºÅ</h2>
            <a class="btn-download" id="downloadLink" href="#" download="miyako-dictionary.html">
                ‚¨áÔ∏è HTML„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            </a>
        </div>
        
        <footer>
            InDIGO - Interactive Dictionary Generation Optimizer | EAF„Éï„Ç°„Ç§„É´„Åã„ÇâÊ§úÁ¥¢ÂèØËÉΩ„Å™ËæûÊõ∏„Çí‰ΩúÊàê
        </footer>
    </div>

<script>
// ============================================================================
// EAF Parser
// ============================================================================

class EAFParser {
    constructor(xmlString) {
        const parser = new DOMParser();
        this.doc = parser.parseFromString(xmlString, 'text/xml');
        this.timeSlots = {};
        this.tiers = {};
        this.annotations = {};
        this.children = {};
        this.mediaFile = null;
        this._parse();
    }
    
    _parse() {
        this._parseMedia();
        this._parseTimeSlots();
        this._parseTiers();
        this._buildRelationships();
    }
    
    _parseMedia() {
        const mediaDesc = this.doc.querySelector('MEDIA_DESCRIPTOR');
        if (mediaDesc) {
            const relativeUrl = mediaDesc.getAttribute('RELATIVE_MEDIA_URL') || '';
            const mediaUrl = mediaDesc.getAttribute('MEDIA_URL') || '';
            this.mediaFile = relativeUrl ? relativeUrl.replace('./', '') : (mediaUrl ? mediaUrl.split('/').pop() : null);
        }
    }
    
    _parseTimeSlots() {
        this.doc.querySelectorAll('TIME_SLOT').forEach(ts => {
            const id = ts.getAttribute('TIME_SLOT_ID');
            const value = ts.getAttribute('TIME_VALUE');
            this.timeSlots[id] = value ? parseInt(value, 10) : 0;
        });
    }
    
    _parseTiers() {
        this.doc.querySelectorAll('TIER').forEach(tierElem => {
            const tierId = tierElem.getAttribute('TIER_ID') || '';
            const parentRef = tierElem.getAttribute('PARENT_REF') || '';
            this.tiers[tierId] = { parentRef, annotationIds: [] };
            
            tierElem.querySelectorAll('ALIGNABLE_ANNOTATION').forEach(aa => {
                const annId = aa.getAttribute('ANNOTATION_ID') || '';
                const ts1 = aa.getAttribute('TIME_SLOT_REF1') || '';
                const ts2 = aa.getAttribute('TIME_SLOT_REF2') || '';
                const av = aa.querySelector('ANNOTATION_VALUE');
                const value = av ? (av.textContent || '') : '';
                this.annotations[annId] = {
                    id: annId, tierId, value, type: 'alignable',
                    startMs: this.timeSlots[ts1] || 0, endMs: this.timeSlots[ts2] || 0, parentRef: null
                };
                this.tiers[tierId].annotationIds.push(annId);
            });
            
            tierElem.querySelectorAll('REF_ANNOTATION').forEach(ra => {
                const annId = ra.getAttribute('ANNOTATION_ID') || '';
                const annRef = ra.getAttribute('ANNOTATION_REF') || '';
                const av = ra.querySelector('ANNOTATION_VALUE');
                const value = av ? (av.textContent || '') : '';
                this.annotations[annId] = { id: annId, tierId, value, type: 'ref', parentRef: annRef };
                this.tiers[tierId].annotationIds.push(annId);
            });
        });
    }
    
    _buildRelationships() {
        for (const [annId, ann] of Object.entries(this.annotations)) {
            if (ann.parentRef) {
                if (!this.children[ann.parentRef]) this.children[ann.parentRef] = [];
                this.children[ann.parentRef].push(annId);
            }
        }
    }
    
    _getChildrenByTier(parentId, tierId) {
        return (this.children[parentId] || []).filter(id => this.annotations[id].tierId === tierId);
    }
    
    toCorpus(tierConfig = {text:'text',trans:'trans',morph:'morph',gloss:'gloss',pos:'pos'}) {
        const result = [];
        const { text: textTier, trans: transTier, morph: morphTier, gloss: glossTier, pos: posTier } = tierConfig;
        if (!this.tiers[textTier]) {
            console.warn(`Text tier '${textTier}' not found`);
            return result;
        }
        
        // Check tier types and relationships
        const morphTierInfo = this.tiers[morphTier];
        
        // Determine relationship between text and morph
        let morphRelation = 'none';
        if (morphTierInfo) {
            if (morphTierInfo.parentRef === textTier) {
                morphRelation = 'child';
            } else if (!morphTierInfo.parentRef) {
                morphRelation = 'aligned';
            } else {
                // Check if morph is a descendant of text (through intermediate tiers)
                let currentParent = morphTierInfo.parentRef;
                let depth = 0;
                while (currentParent && depth < 5) {
                    if (currentParent === textTier) {
                        morphRelation = 'descendant';
                        break;
                    }
                    const parentTier = this.tiers[currentParent];
                    currentParent = parentTier ? parentTier.parentRef : null;
                    depth++;
                }
            }
        }
        
        console.log(`Parsing with: text=${textTier}, morph=${morphTier}, relation=${morphRelation}`);
        
        for (const textAnnId of this.tiers[textTier].annotationIds) {
            const textAnn = this.annotations[textAnnId];
            const entry = { text: textAnn.value };
            
            // Time info
            let startMs = null, endMs = null;
            if (textAnn.type === 'alignable') {
                startMs = textAnn.startMs;
                endMs = textAnn.endMs;
                entry.start_time = Math.round(startMs / 10) / 100;
                entry.end_time = Math.round(endMs / 10) / 100;
            }
            
            // Trans - try as child first, then by time overlap
            if (this.tiers[transTier]) {
                let transChildren = this._getChildrenByTier(textAnnId, transTier);
                if (transChildren.length > 0) {
                    entry.trans = this.annotations[transChildren[0]].value;
                } else {
                    // Try descendants
                    const transDesc = this._getDescendantsByTier(textAnnId, transTier);
                    if (transDesc.length > 0) {
                        entry.trans = this.annotations[transDesc[0]].value;
                    } else if (startMs !== null) {
                        // Try to find by time overlap
                        const transAnn = this._findAnnotationByTimeOverlap(transTier, startMs, endMs);
                        if (transAnn) entry.trans = transAnn.value;
                    }
                }
            }
            
            // Morphs
            const morphIds = [];
            const morphValues = [];
            if (this.tiers[morphTier]) {
                if (morphRelation === 'child') {
                    // Direct child
                    const morphChildren = this._getChildrenByTier(textAnnId, morphTier);
                    for (const morphId of morphChildren) {
                        morphIds.push(morphId);
                        morphValues.push(this.annotations[morphId].value);
                    }
                } else if (morphRelation === 'descendant') {
                    // Descendant (through intermediate tiers)
                    const morphDescs = this._getDescendantsByTier(textAnnId, morphTier);
                    for (const morphId of morphDescs) {
                        morphIds.push(morphId);
                        morphValues.push(this.annotations[morphId].value);
                    }
                } else if (startMs !== null) {
                    // Find by time
                    const morphAnns = this._findAnnotationsByTimeRange(morphTier, startMs, endMs);
                    for (const morphAnn of morphAnns) {
                        morphIds.push(morphAnn.id);
                        morphValues.push(morphAnn.value);
                    }
                }
            }
            if (morphValues.length > 0) {
                entry.morphs = morphValues;
            }
            
            // Gloss
            if (this.tiers[glossTier] && morphIds.length > 0) {
                const glosses = [];
                for (const morphId of morphIds) {
                    // Try direct children first
                    let glossChildren = this._getChildrenByTier(morphId, glossTier);
                    if (glossChildren.length > 0) {
                        glosses.push(this.annotations[glossChildren[0]].value);
                    } else {
                        // Try descendants
                        const glossDescs = this._getDescendantsByTier(morphId, glossTier);
                        if (glossDescs.length > 0) {
                            glosses.push(this.annotations[glossDescs[0]].value);
                        } else {
                            glosses.push('');
                        }
                    }
                }
                entry.gloss = glosses;
            }
            
            // POS
            if (this.tiers[posTier] && morphIds.length > 0) {
                const poses = [];
                for (const morphId of morphIds) {
                    let posChildren = this._getChildrenByTier(morphId, posTier);
                    if (posChildren.length > 0) {
                        poses.push(this.annotations[posChildren[0]].value);
                    } else {
                        const posDescs = this._getDescendantsByTier(morphId, posTier);
                        if (posDescs.length > 0) {
                            poses.push(this.annotations[posDescs[0]].value);
                        } else {
                            poses.push('');
                        }
                    }
                }
                entry.pos = poses;
            }
            
            result.push(entry);
        }
        return result;
    }
    
    // Get all descendants in a specific tier (traverse through intermediate tiers)
    _getDescendantsByTier(ancestorId, targetTierId, maxDepth = 5) {
        const result = [];
        const queue = [{ id: ancestorId, depth: 0 }];
        const visited = new Set();
        
        while (queue.length > 0) {
            const { id, depth } = queue.shift();
            if (visited.has(id) || depth > maxDepth) continue;
            visited.add(id);
            
            const children = this.children[id] || [];
            for (const childId of children) {
                const childAnn = this.annotations[childId];
                if (childAnn.tierId === targetTierId) {
                    result.push(childId);
                } else {
                    // Continue searching through this child
                    queue.push({ id: childId, depth: depth + 1 });
                }
            }
        }
        return result;
    }
    
    _findAnnotationByTimeOverlap(tierId, startMs, endMs) {
        if (!this.tiers[tierId]) return null;
        for (const annId of this.tiers[tierId].annotationIds) {
            const ann = this.annotations[annId];
            if (ann.type === 'alignable') {
                // Check overlap
                if (ann.startMs < endMs && ann.endMs > startMs) {
                    return ann;
                }
            }
        }
        return null;
    }
    
    _findAnnotationsByTimeRange(tierId, startMs, endMs) {
        const result = [];
        if (!this.tiers[tierId]) return result;
        for (const annId of this.tiers[tierId].annotationIds) {
            const ann = this.annotations[annId];
            if (ann.type === 'alignable') {
                // Check if annotation is within range
                if (ann.startMs >= startMs && ann.endMs <= endMs) {
                    result.push(ann);
                }
            }
        }
        // Sort by start time
        result.sort((a, b) => a.startMs - b.startMs);
        return result;
    }
    
    getMediaFile() { return this.mediaFile; }
}

// ============================================================================
// Dictionary Builder
// ============================================================================

class DictionaryBuilder {
    constructor(maxExamples = 3) {
        this.maxExamples = maxExamples;
        this.tokenFreq = new Map();
        this.allomorphToHead = new Map();
        this.entries = new Map();
        this.examplesByKey = new Map();
    }
    
    build(corpusItems) {
        this.tokenFreq.clear();
        this.allomorphToHead.clear();
        this.entries.clear();
        this.examplesByKey.clear();
        
        console.log('DictionaryBuilder: Processing', corpusItems.length, 'items');
        
        this._countTokens(corpusItems);
        console.log('DictionaryBuilder: Found', this.tokenFreq.size, 'unique tokens');
        
        this._findAllomorphs();
        this._createEntries();
        console.log('DictionaryBuilder: Created', this.entries.size, 'entries');
        
        this._collectExamples(corpusItems);
        this._assignMorphIndices();
        
        return this._toList();
    }
    
    _countTokens(items) {
        for (const item of items) {
            const morphs = item.morphs || [];
            const glosses = item.gloss || [];
            const posList = item.pos || [];
            
            for (let i = 0; i < morphs.length; i++) {
                const m = morphs[i];
                const g = i < glosses.length ? glosses[i] : '';
                const p = i < posList.length ? posList[i] : '';  // pos„ÅåÁ©∫„Åß„ÇÇOK
                
                if (m && m !== 'XXX' && g) {  // morph„Å®gloss„Åå„ÅÇ„Çå„Å∞ÁôªÈå≤
                    const key = `${m}|${p}|${g}`;
                    this.tokenFreq.set(key, (this.tokenFreq.get(key) || 0) + 1);
                }
            }
        }
    }
    
    _findAllomorphs() {
        const groups = new Map();
        for (const [key, count] of this.tokenFreq) {
            const [morph, pos, gloss] = key.split('|');
            const gk = `${pos}|${gloss}`;
            if (!groups.has(gk)) groups.set(gk, []);
            groups.get(gk).push({ morph, count });
        }
        for (const [gk, morphs] of groups) {
            if (morphs.length > 1) {
                morphs.sort((a, b) => b.count - a.count);
                const head = morphs[0].morph;
                const [pos, gloss] = gk.split('|');
                for (let i = 1; i < morphs.length; i++) {
                    this.allomorphToHead.set(`${pos}|${gloss}|${morphs[i].morph}`, head);
                }
            }
        }
    }
    
    _createEntries() {
        for (const key of this.tokenFreq.keys()) {
            const [morph, pos, gloss] = key.split('|');
            const alloKey = `${pos}|${gloss}|${morph}`;
            if (this.allomorphToHead.has(alloKey)) {
                const head = this.allomorphToHead.get(alloKey);
                const entryKey = `${head}|${pos}|${gloss}`;
                if (!this.entries.has(entryKey)) this.entries.set(entryKey, { morph: head, pos, gloss, allomorphs: [] });
                this.entries.get(entryKey).allomorphs.push(morph);
            } else {
                if (!this.entries.has(key)) this.entries.set(key, { morph, pos, gloss, allomorphs: [] });
            }
        }
    }
    
    _collectExamples(items) {
        for (const item of items) {
            const { text, trans, morphs = [], gloss: glosses = [], pos: posList = [], start_time, end_time, _audio_file } = item;
            if (!text || !morphs.length) continue;
            const seen = new Set();
            for (let i = 0; i < morphs.length; i++) {
                const m = morphs[i];
                const g = i < glosses.length ? glosses[i] : '';
                const p = i < posList.length ? posList[i] : '';
                
                if (!m || m === 'XXX' || !g) continue;
                
                const alloKey = `${p}|${g}|${m}`;
                const head = this.allomorphToHead.get(alloKey) || m;
                const entryKey = `${head}|${p}|${g}`;
                if (!this.entries.has(entryKey) || seen.has(entryKey)) continue;
                seen.add(entryKey);
                if (!this.examplesByKey.has(entryKey)) this.examplesByKey.set(entryKey, []);
                this.examplesByKey.get(entryKey).push({
                    text, trans, morphs, glosses, pos_list: posList,
                    target_index: i, audio_file: _audio_file, start_time, end_time
                });
            }
        }
        for (const [key, entry] of this.entries) {
            const all = this.examplesByKey.get(key) || [];
            entry.examples = [...all.filter(e => e.trans), ...all.filter(e => !e.trans)].slice(0, this.maxExamples);
        }
    }
    
    _assignMorphIndices() {
        const counts = new Map();
        for (const e of this.entries.values()) counts.set(e.morph, (counts.get(e.morph) || 0) + 1);
        const indices = new Map();
        for (const key of [...this.entries.keys()].sort()) {
            const entry = this.entries.get(key);
            if (counts.get(entry.morph) > 1) {
                const idx = (indices.get(entry.morph) || 0) + 1;
                indices.set(entry.morph, idx);
                entry.morph_index = idx;
            } else {
                entry.morph_index = null;
            }
        }
    }
    
    _toList() {
        const result = [...this.entries.values()];
        result.forEach(e => e.allomorphs = [...new Set(e.allomorphs)].sort());
        result.sort((a, b) => a.morph.toLowerCase().localeCompare(b.morph.toLowerCase()) || (a.pos || '').localeCompare(b.pos || ''));
        return result;
    }
}

// ============================================================================
// CSV Parser
// ============================================================================

function parseCSV(content) {
    const lines = content.split(/\r?\n/);
    if (lines.length < 2) throw new Error('CSV„ÅåÁ©∫„Åß„Åô');
    
    // „Éò„ÉÉ„ÉÄ„ÉºËß£Êûê
    const headers = parseCSVLine(lines[0]);
    const headerMap = {};
    headers.forEach((h, i) => headerMap[h.toLowerCase().trim()] = i);
    
    // ÂøÖÈ†à„Ç´„É©„É†„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    const morphIdx = headerMap['morph'];
    const glossIdx = headerMap['gloss'];
    if (morphIdx === undefined || glossIdx === undefined) {
        throw new Error('CSV„Å´„ÅØ morph „Å® gloss „Ç´„É©„É†„ÅåÂøÖË¶Å„Åß„Åô');
    }
    
    const posIdx = headerMap['pos'];
    const allomorphsIdx = headerMap['allomorphs'];
    const morphIndexIdx = headerMap['morph_index'];
    const exTextIdx = headerMap['ex_text'];
    const exTransIdx = headerMap['ex_trans'];
    const exMorphsIdx = headerMap['ex_morphs'];
    const exGlossesIdx = headerMap['ex_glosses'];
    const exAudioIdx = headerMap['ex_audio'];
    const exStartIdx = headerMap['ex_start'];
    const exEndIdx = headerMap['ex_end'];
    const exTargetIdx = headerMap['ex_target'];
    
    // „Ç®„É≥„Éà„É™„Çí„Éû„ÉÉ„Éó„ÅßÁÆ°ÁêÜÔºàÂêå„Åòmorph+pos+gloss„ÅØÁµ±ÂêàÔºâ
    const entryMap = new Map();
    let exampleCount = 0;
    
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const cols = parseCSVLine(line);
        const morph = cols[morphIdx]?.trim() || '';
        const gloss = cols[glossIdx]?.trim() || '';
        if (!morph || !gloss) continue;
        
        const pos = posIdx !== undefined ? (cols[posIdx]?.trim() || '') : '';
        const key = `${morph}|${pos}|${gloss}`;
        
        if (!entryMap.has(key)) {
            const allomorphsStr = allomorphsIdx !== undefined ? (cols[allomorphsIdx]?.trim() || '') : '';
            const allomorphs = allomorphsStr ? allomorphsStr.split('|').map(s => s.trim()).filter(s => s) : [];
            const morphIndex = morphIndexIdx !== undefined ? (cols[morphIndexIdx]?.trim() || null) : null;
            
            entryMap.set(key, {
                morph,
                pos,
                gloss,
                allomorphs,
                morph_index: morphIndex ? parseInt(morphIndex) : null,
                examples: []
            });
        }
        
        // Áî®‰æã„Åå„ÅÇ„Çå„Å∞ËøΩÂä†
        const exText = exTextIdx !== undefined ? (cols[exTextIdx]?.trim() || '') : '';
        if (exText) {
            const entry = entryMap.get(key);
            const exMorphsStr = exMorphsIdx !== undefined ? (cols[exMorphsIdx]?.trim() || '') : '';
            const exGlossesStr = exGlossesIdx !== undefined ? (cols[exGlossesIdx]?.trim() || '') : '';
            
            entry.examples.push({
                text: exText,
                trans: exTransIdx !== undefined ? (cols[exTransIdx]?.trim() || '') : '',
                morphs: exMorphsStr ? exMorphsStr.split('|') : [],
                glosses: exGlossesStr ? exGlossesStr.split('|') : [],
                audio_file: exAudioIdx !== undefined ? (cols[exAudioIdx]?.trim() || undefined) : undefined,
                start_time: exStartIdx !== undefined && cols[exStartIdx] ? parseFloat(cols[exStartIdx]) : undefined,
                end_time: exEndIdx !== undefined && cols[exEndIdx] ? parseFloat(cols[exEndIdx]) : undefined,
                target_index: exTargetIdx !== undefined && cols[exTargetIdx] ? parseInt(cols[exTargetIdx]) : 0
            });
            exampleCount++;
        }
    }
    
    return {
        entries: [...entryMap.values()],
        exampleCount
    };
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (inQuotes) {
            if (char === '"') {
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = false;
                }
            } else {
                current += char;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
    }
    result.push(current);
    return result;
}

// ============================================================================
// State
// ============================================================================

let corpusData = [];
let loadedFiles = [];
let dictionaryData = [];
let rawEAFData = [];  // Áîü„ÅÆEAF„Éá„Éº„Çø„Çí‰øùÊåÅÔºàÂÜç„Éë„Éº„ÇπÁî®Ôºâ
let audioUrls = {};   // EAF„Éï„Ç°„Ç§„É´Âêç ‚Üí Èü≥Â£∞URL
let tierConfigs = {}; // EAF„Éï„Ç°„Ç§„É´Âêç ‚Üí {text, trans, morph, gloss, pos}
let csvDictionaryData = [];  // CSV„Åã„ÇâË™≠„ÅøËæº„Çì„Å†ËæûÊõ∏„Ç®„É≥„Éà„É™

function getTierConfigForFile(filename) {
    return tierConfigs[filename] || {
        text: 'text',
        trans: 'trans',
        morph: 'morph',
        gloss: 'gloss',
        pos: 'pos'
    };
}

function updateTierConfigList() {
    const container = document.getElementById('tierConfigList');
    const eafFiles = rawEAFData;
    
    if (eafFiles.length === 0) {
        document.getElementById('tierSection').style.display = 'none';
        return;
    }
    
    document.getElementById('tierSection').style.display = 'block';
    
    container.innerHTML = eafFiles.map(({filename, parser}) => {
        const tierNames = Object.keys(parser.tiers);
        const config = tierConfigs[filename] || autoDetectTiersForFile(parser);
        tierConfigs[filename] = config;
        
        // TierÊÉÖÂ†±„ÇíË°®Á§∫Áî®„Å´‰ΩúÊàê
        const tierInfoHtml = tierNames.slice(0, 8).map(name => {
            const tier = parser.tiers[name];
            const count = tier.annotationIds.length;
            return `<span class="tier-info-tag">${name}(${count})</span>`;
        }).join('') + (tierNames.length > 8 ? `<span class="tier-info-more">+${tierNames.length - 8}</span>` : '');
        
        // selectÁî®„ÅÆoptionÁîüÊàêÈñ¢Êï∞
        const makeOptions = (field) => {
            const selected = config[field] || '';
            let opts = `<option value=""${selected === '' ? ' selected' : ''}>(„Å™„Åó)</option>`;
            for (const t of tierNames) {
                opts += `<option value="${t}"${t === selected ? ' selected' : ''}>${t}</option>`;
            }
            return opts;
        };
        
        return `
            <div class="tier-config-item">
                <div class="tier-config-header">
                    <strong>${filename}</strong>
                    <span class="tier-config-count" id="count-${filename.replace(/[^a-zA-Z0-9]/g, '_')}">0Êñá</span>
                </div>
                <div class="tier-info-tags">${tierInfoHtml}</div>
                <div class="tier-config-grid">
                    <div class="tier-select">
                        <label>text</label>
                        <select data-file="${filename}" data-field="text">${makeOptions('text')}</select>
                    </div>
                    <div class="tier-select">
                        <label>trans</label>
                        <select data-file="${filename}" data-field="trans">${makeOptions('trans')}</select>
                    </div>
                    <div class="tier-select">
                        <label>morph</label>
                        <select data-file="${filename}" data-field="morph">${makeOptions('morph')}</select>
                    </div>
                    <div class="tier-select">
                        <label>gloss</label>
                        <select data-file="${filename}" data-field="gloss">${makeOptions('gloss')}</select>
                    </div>
                    <div class="tier-select">
                        <label>pos</label>
                        <select data-file="${filename}" data-field="pos">${makeOptions('pos')}</select>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºËøΩÂä†
    container.querySelectorAll('select').forEach(select => {
        select.onchange = (e) => {
            const file = e.target.dataset.file;
            const field = e.target.dataset.field;
            if (!tierConfigs[file]) tierConfigs[file] = {};
            tierConfigs[file][field] = e.target.value;
        };
    });
}

function autoDetectTiersForFile(parser) {
    const tierNames = Object.keys(parser.tiers);
    const config = { text: '', trans: '', morph: '', gloss: '', pos: '' };
    
    // „Çà„Åè„ÅÇ„Çã„Éë„Çø„Éº„É≥ÔºàÂÑ™ÂÖàÈ†Ü‰ΩçÈ†ÜÔºâ
    const patterns = {
        text: ['text', 'tx', 'utterance', 'sentence', 'ref', 'default', 'text0', 'text1', 'text2'],
        trans: ['trans', 'translation', 'ft', 'free', 'freeTranslation'],
        morph: ['morph', 'mb', 'morpheme', 'word', 'wd', 'morph2'],
        gloss: ['gloss', 'gl', 'ge', 'glosses', 'gloss1'],
        pos: ['pos', 'ps', 'part-of-speech', 'cat', 'mcat']
    };
    
    for (const [field, candidates] of Object.entries(patterns)) {
        // 1. ÂÆåÂÖ®‰∏ÄËá¥Ôºà@„Å™„ÅóÔºâ„ÇíÊúÄÂÑ™ÂÖà
        let found = tierNames.find(t => candidates.includes(t.toLowerCase()));
        if (found) {
            config[field] = found;
            continue;
        }
        
        // 2. @„ÅÆÂâç„ÅÆÈÉ®ÂàÜ„ÅßÂÆåÂÖ®‰∏ÄËá¥
        found = tierNames.find(t => {
            const base = t.split('@')[0].toLowerCase();
            return candidates.includes(base);
        });
        if (found) {
            config[field] = found;
            continue;
        }
        
        // 3. ÈÉ®ÂàÜ‰∏ÄËá¥
        found = tierNames.find(t => {
            const lower = t.toLowerCase();
            return candidates.some(c => lower.includes(c));
        });
        if (found) {
            config[field] = found;
        }
    }
    
    // ÁâπÊÆä„Ç±„Éº„Çπ: root„ÅÆtierÔºàalignableÔºâ„ÇíÊé¢„Åô
    if (!config.text) {
        const rootTiers = tierNames.filter(t => !parser.tiers[t].parentRef);
        const alignableTier = rootTiers.find(t => {
            const firstAnnId = parser.tiers[t].annotationIds[0];
            return firstAnnId && parser.annotations[firstAnnId]?.type === 'alignable';
        });
        if (alignableTier) {
            config.text = alignableTier;
        }
    }
    
    console.log(`Auto-detected tiers for ${parser.mediaFile || 'file'}:`, config);
    return config;
}

function updateAudioUrlList() {
    const container = document.getElementById('audioUrlList');
    const eafFiles = loadedFiles.filter(f => f.name.toLowerCase().endsWith('.eaf'));
    
    if (eafFiles.length === 0) {
        document.getElementById('audioSection').style.display = 'none';
        return;
    }
    
    document.getElementById('audioSection').style.display = 'block';
    
    container.innerHTML = eafFiles.map(f => {
        const baseName = f.baseName;
        const currentUrl = audioUrls[f.name] || '';
        return `
            <div class="audio-url-item">
                <label>${f.name}</label>
                <input type="text" 
                       class="audio-url-input" 
                       data-eaf="${f.name}"
                       data-basename="${baseName}"
                       value="${currentUrl}"
                       placeholder="https://zenodo.org/records/xxxxx/files/${baseName}.wav?download=1">
            </div>
        `;
    }).join('');
    
    // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºËøΩÂä†
    container.querySelectorAll('.audio-url-input').forEach(input => {
        input.oninput = (e) => {
            audioUrls[e.target.dataset.eaf] = e.target.value;
        };
    });
}

// ============================================================================
// File Handling
// ============================================================================

function detectFileType(data) {
    if (Array.isArray(data) && data.length > 0) {
        const first = data[0];
        if (first.morph && first.gloss && first.examples) return 'dictionary';
        if (first.text && (first.morphs || first.gloss)) return 'corpus';
    }
    return 'unknown';
}

function handleFile(file, content) {
    const filename = file.name;
    
    if (filename.toLowerCase().endsWith('.eaf')) {
        try {
            const parser = new EAFParser(content);
            
            // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË°®Á§∫
            const tierNames = Object.keys(parser.tiers);
            
            // Build tier tree structure
            const rootTiers = tierNames.filter(t => !parser.tiers[t].parentRef);
            const buildTree = (tierId, indent = '') => {
                const tier = parser.tiers[tierId];
                const count = tier.annotationIds.length;
                const firstAnnId = tier.annotationIds[0];
                const firstAnn = firstAnnId ? parser.annotations[firstAnnId] : null;
                const firstValue = firstAnn ? (firstAnn.value || '').substring(0, 25) : '';
                const annType = firstAnn ? `[${firstAnn.type}]` : '';
                
                let result = `${indent}${tierId}: ${count}‰ª∂ ${annType} "${firstValue}"\n`;
                
                // Find children
                const childTiers = tierNames.filter(t => parser.tiers[t].parentRef === tierId);
                for (const childId of childTiers) {
                    result += buildTree(childId, indent + '  ‚îú‚îÄ');
                }
                return result;
            };
            
            let tierTree = 'TierÈöéÂ±§ÊßãÈÄ†:\n';
            for (const rootId of rootTiers) {
                tierTree += buildTree(rootId, '');
            }
            
            const debugInfo = `„Éï„Ç°„Ç§„É´: ${filename}\n„É°„Éá„Ç£„Ç¢: ${parser.mediaFile || '(„Å™„Åó)'}\n\n${tierTree}`;
            
            document.getElementById('debugBox').style.display = 'block';
            document.getElementById('debugInfo').textContent = debugInfo;
            
            // Áîü„Éá„Éº„Çø„Çí‰øùÂ≠ò
            rawEAFData.push({ filename, content, parser });
            
            // TierË®≠ÂÆö„ÇíËá™ÂãïÊ§úÂá∫
            if (!tierConfigs[filename]) {
                tierConfigs[filename] = autoDetectTiersForFile(parser);
            }
            
            // ÁèæÂú®„ÅÆTierË®≠ÂÆö„Åß„Éë„Éº„Çπ
            const tierConfig = tierConfigs[filename];
            const corpus = parser.toCorpus(tierConfig);
            const baseName = filename.replace(/\.eaf$/i, '');
            
            for (const item of corpus) {
                item._base_name = baseName;
                item._source_file = filename;
                corpusData.push(item);
            }
            
            loadedFiles.push({ name: filename, count: corpus.length, baseName });
            console.log(`Loaded EAF: ${filename} (${corpus.length} sentences)`);
            console.log('Tiers found:', tierNames.join(','));
            console.log('Auto-detected config:', tierConfig);
        } catch (err) {
            console.error(err);
            alert(`EAF„Éë„Éº„Çπ„Ç®„É©„Éº: ${filename}\n${err.message}`);
        }
    } else if (filename.endsWith('.json')) {
        try {
            const data = JSON.parse(content);
            const type = detectFileType(data);
            
            if (type === 'dictionary') {
                let count = 0;
                for (const entry of data) {
                    for (const ex of (entry.examples || [])) {
                        const item = {
                            text: ex.text, trans: ex.trans, morphs: ex.morphs,
                            gloss: ex.glosses, pos: ex.pos_list,
                            start_time: ex.start_time, end_time: ex.end_time,
                            _audio_file: ex.audio_file, _source_file: filename
                        };
                        corpusData.push(item);
                        count++;
                    }
                }
                loadedFiles.push({ name: filename, count, baseName: filename.replace('.json', '') });
            } else if (type === 'corpus') {
                const baseName = filename.replace('.json', '');
                for (const item of data) {
                    item._base_name = baseName;
                    item._source_file = filename;
                    corpusData.push(item);
                }
                loadedFiles.push({ name: filename, count: data.length, baseName });
            } else {
                alert(`‰∏çÊòé„Å™JSONÂΩ¢Âºè: ${filename}`);
            }
        } catch (err) {
            alert(`JSON„Éë„Éº„Çπ„Ç®„É©„Éº: ${filename}`);
        }
    } else if (filename.toLowerCase().endsWith('.csv')) {
        try {
            const result = parseCSV(content);
            if (result.entries.length > 0) {
                // CSV„Åã„ÇâdictionaryData„Å´Áõ¥Êé•ËøΩÂä†Ôºà„ÇΩ„Éº„Çπ„Éï„Ç°„Ç§„É´Âêç„ÇíË®òÈå≤Ôºâ
                for (const entry of result.entries) {
                    entry._source_file = filename;
                }
                csvDictionaryData.push(...result.entries);
                loadedFiles.push({ name: filename, count: result.entries.length, baseName: filename.replace(/\.csv$/i, ''), type: 'csv' });
                console.log(`Loaded CSV: ${filename} (${result.entries.length} entries, ${result.exampleCount} examples)`);
            } else {
                alert(`CSV„Å´„Ç®„É≥„Éà„É™„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${filename}`);
            }
        } catch (err) {
            console.error(err);
            alert(`CSV„Éë„Éº„Çπ„Ç®„É©„Éº: ${filename}\n${err.message}`);
        }
    }
    
    updateUI();
}

function reloadWithTierConfig() {
    // Êó¢Â≠ò„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
    corpusData = [];
    loadedFiles = [];
    
    console.log('Reloading with tier configs:', JSON.stringify(tierConfigs));
    
    // ‰øùÂ≠ò„Åó„ÅüEAF„Éá„Éº„Çø„ÇíÂÜç„Éë„Éº„Çπ
    for (const { filename, parser } of rawEAFData) {
        const tierConfig = tierConfigs[filename] || autoDetectTiersForFile(parser);
        const corpus = parser.toCorpus(tierConfig);
        const baseName = filename.replace(/\.eaf$/i, '');
        
        console.log(`Re-parsed ${filename}: ${corpus.length} sentences`);
        if (corpus.length > 0 && corpus[0].morphs) {
            console.log(`  Sample morphs: ${corpus[0].morphs.slice(0, 5).join(', ')}`);
            console.log(`  Sample gloss: ${(corpus[0].gloss || []).slice(0, 5).join(', ')}`);
        }
        
        for (const item of corpus) {
            item._base_name = baseName;
            item._source_file = filename;
            corpusData.push(item);
        }
        
        loadedFiles.push({ name: filename, count: corpus.length, baseName });
    }
    
    updateUI();
    
    // „Ç´„Ç¶„É≥„ÉàË°®Á§∫„ÇíÊõ¥Êñ∞
    for (const f of loadedFiles) {
        const countEl = document.getElementById(`count-${f.name.replace(/[^a-zA-Z0-9]/g, '_')}`);
        if (countEl) {
            countEl.textContent = `${f.count}Êñá`;
            countEl.className = f.count > 0 ? 'tier-config-count' : 'tier-config-count zero';
        }
    }
    
    // „Çµ„É≥„Éó„É´„Éá„Éº„Çø„ÇíË°®Á§∫
    if (corpusData.length > 0) {
        const sample = corpusData[0];
        alert(`„Éë„Éº„ÇπÁµêÊûú„Çµ„É≥„Éó„É´Ôºà1ÊñáÁõÆÔºâ:\n\ntext: ${sample.text || '(„Å™„Åó)'}\nmorphs: ${(sample.morphs || []).slice(0, 5).join(', ')} (${(sample.morphs || []).length}‰ª∂)\ngloss: ${(sample.gloss || []).slice(0, 5).join(', ')} (${(sample.gloss || []).length}‰ª∂)\npos: ${(sample.pos || []).slice(0, 5).join(', ')} (${(sample.pos || []).length}‰ª∂)\ntrans: ${sample.trans || '(„Å™„Åó)'}`);
    }
}

function updateUI() {
    // Update file tags
    const filesEl = document.getElementById('loadedFiles');
    filesEl.innerHTML = loadedFiles.map((f, i) => `
        <span class="file-tag ${f.type === 'csv' ? 'csv-file' : ''}">
            ${f.name}
            <span class="count">${f.count}${f.type === 'csv' ? '„Ç®„É≥„Éà„É™' : 'Êñá'}</span>
            <span class="remove" onclick="removeFile(${i})">‚úï</span>
        </span>
    `).join('');
    
    // Update tier config list (per-file)
    updateTierConfigList();
    
    // Update audio URL list
    updateAudioUrlList();
    
    // Build dictionary
    const hasCorpus = corpusData.length > 0;
    const hasCSV = csvDictionaryData.length > 0;
    
    if (hasCorpus || hasCSV) {
        // „Ç≥„Éº„Éë„Çπ„Åã„ÇâËæûÊõ∏„ÇíÊßãÁØâ
        let builtDict = [];
        if (hasCorpus) {
            const builder = new DictionaryBuilder(3);
            builtDict = builder.build(corpusData);
        }
        
        // CSV„ÅÆ„Éá„Éº„Çø„ÇíÁµ±Âêà
        if (hasCSV) {
            dictionaryData = mergeDictionaries(builtDict, csvDictionaryData);
        } else {
            dictionaryData = builtDict;
        }
        
        const totalSentences = corpusData.length + csvDictionaryData.reduce((sum, e) => sum + (e.examples?.length || 0), 0);
        
        document.getElementById('statsBox').style.display = 'block';
        document.getElementById('statFiles').textContent = loadedFiles.length;
        document.getElementById('statSentences').textContent = totalSentences;
        document.getElementById('statEntries').textContent = dictionaryData.length;
        document.getElementById('btnGenerate').disabled = false;
    } else {
        document.getElementById('statsBox').style.display = 'none';
        document.getElementById('btnGenerate').disabled = true;
        dictionaryData = [];
    }
}

function mergeDictionaries(dict1, dict2) {
    const merged = new Map();
    
    // dict1„ÇíËøΩÂä†
    for (const entry of dict1) {
        const key = `${entry.morph}|${entry.pos}|${entry.gloss}`;
        merged.set(key, { ...entry });
    }
    
    // dict2„ÇíËøΩÂä†ÔºàÊó¢Â≠ò„Ç®„É≥„Éà„É™„ÅØÁî®‰æã„Çí„Éû„Éº„Ç∏Ôºâ
    for (const entry of dict2) {
        const key = `${entry.morph}|${entry.pos}|${entry.gloss}`;
        if (merged.has(key)) {
            const existing = merged.get(key);
            // Áï∞ÂΩ¢ÊÖã„Çí„Éû„Éº„Ç∏
            const allAllomorphs = new Set([...(existing.allomorphs || []), ...(entry.allomorphs || [])]);
            existing.allomorphs = [...allAllomorphs].sort();
            // Áî®‰æã„Çí„Éû„Éº„Ç∏ÔºàÈáçË§á„ÇíÈÅø„Åë„Å¶ÊúÄÂ§ß3‰ª∂Ôºâ
            const existingTexts = new Set((existing.examples || []).map(e => e.text));
            for (const ex of (entry.examples || [])) {
                if (!existingTexts.has(ex.text) && (existing.examples || []).length < 3) {
                    existing.examples = existing.examples || [];
                    existing.examples.push(ex);
                }
            }
        } else {
            merged.set(key, { ...entry });
        }
    }
    
    // „ÇΩ„Éº„Éà„Åó„Å¶Ëøî„Åô
    return [...merged.values()].sort((a, b) => 
        a.morph.toLowerCase().localeCompare(b.morph.toLowerCase()) || 
        (a.pos || '').localeCompare(b.pos || '')
    );
}

function removeFile(index) {
    const file = loadedFiles[index];
    
    if (file.type === 'csv') {
        // CSV„Éï„Ç°„Ç§„É´„ÅÆÂ†¥Âêà„ÄÅË©≤ÂΩì„Åô„Çã„Ç®„É≥„Éà„É™„ÇíÂâäÈô§
        csvDictionaryData = csvDictionaryData.filter(item => item._source_file !== file.name);
    } else {
        corpusData = corpusData.filter(item => item._source_file !== file.name);
        rawEAFData = rawEAFData.filter(item => item.filename !== file.name);
        delete audioUrls[file.name];
        delete tierConfigs[file.name];
    }
    
    loadedFiles.splice(index, 1);
    
    if (rawEAFData.length === 0) {
        document.getElementById('debugBox').style.display = 'none';
        document.getElementById('tierSection').style.display = 'none';
    }
    
    updateUI();
}

// ============================================================================
// HTML Generation
// ============================================================================

function generateHTML() {
    const title = document.getElementById('titleInput').value || 'ÂÆÆÂè§Ë™ûËæûÊõ∏';
    const subtitle = document.getElementById('subtitleInput').value || '';
    
    // „Éá„Éê„ÉÉ„Ç∞: corpusData„ÅÆÁ¢∫Ë™ç
    console.log('=== Generate HTML Debug ===');
    console.log('corpusData length:', corpusData.length);
    if (corpusData.length > 0) {
        console.log('Sample corpus item:', JSON.stringify(corpusData[0], null, 2));
    }
    console.log('dictionaryData length:', dictionaryData.length);
    if (dictionaryData.length > 0) {
        console.log('Sample dictionary entry:', JSON.stringify(dictionaryData[0], null, 2));
    }
    
    // ËæûÊõ∏„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅØÂÜçÊßãÁØâ„ÇíË©¶„Åø„Çã
    if (dictionaryData.length === 0 && corpusData.length > 0) {
        console.log('Dictionary is empty, rebuilding...');
        const builder = new DictionaryBuilder(3);
        dictionaryData = builder.build(corpusData);
        console.log('Rebuilt dictionary length:', dictionaryData.length);
    }
    
    // Èü≥Â£∞URL„Çíexamples„Å´Ë®≠ÂÆö
    for (const entry of dictionaryData) {
        for (const ex of (entry.examples || [])) {
            if (ex.audio_file === undefined) {
                // corpusData„Åã„ÇâÂÖÉ„ÅÆ„ÇΩ„Éº„Çπ„Éï„Ç°„Ç§„É´Âêç„ÇíË¶ã„Å§„Åë„Çã
                const corpusItem = corpusData.find(c => c.text === ex.text);
                if (corpusItem && corpusItem._source_file) {
                    const url = audioUrls[corpusItem._source_file];
                    if (url) {
                        ex.audio_file = url;
                    }
                }
            }
        }
    }
    
    if (dictionaryData.length === 0) {
        alert('ËæûÊõ∏„Éá„Éº„Çø„ÅåÁ©∫„Åß„Åô„ÄÇ\n\n„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±:\n- corpusData: ' + corpusData.length + '‰ª∂\n- ÊúÄÂàù„ÅÆÊñá„ÅÆmorphs: ' + JSON.stringify(corpusData[0]?.morphs) + '\n- ÊúÄÂàù„ÅÆÊñá„ÅÆgloss: ' + JSON.stringify(corpusData[0]?.gloss));
        return;
    }
    
    const html = generateDictionaryHTML(title, subtitle, dictionaryData);
    
    // Create download link
    const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const downloadLink = document.getElementById('downloadLink');
    downloadLink.href = url;
    downloadLink.download = 'miyako-dictionary.html';
    
    document.getElementById('outputSection').classList.add('show');
    downloadLink.scrollIntoView({ behavior: 'smooth' });
}

function generateDictionaryHTML(title, subtitle, dictionary) {
    // JSONÂÜÖ„ÅÆÂç±Èô∫„Å™ÊñáÂ≠ó„Çí„Ç®„Çπ„Ç±„Éº„Éó
    const dictJSON = JSON.stringify(dictionary)
        .replace(/</g, '\\u003c')
        .replace(/>/g, '\\u003e')
        .replace(/&/g, '\\u0026')
        .replace(/'/g, '\\u0027');
    
    return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${escapeHtml(title)}</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif; background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 950px; margin: 0 auto; background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; padding: 30px; text-align: center; }
        header h1 { font-size: 28px; margin-bottom: 8px; }
        header p { opacity: 0.8; font-size: 14px; }
        .search-section { padding: 20px 30px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; }
        .mode-toggle { display: flex; gap: 0; margin-bottom: 15px; border-radius: 8px; overflow: hidden; border: 2px solid #3949ab; }
        .mode-btn { flex: 1; padding: 10px 20px; border: none; background: white; cursor: pointer; font-size: 14px; font-weight: bold; color: #3949ab; transition: all 0.2s; }
        .mode-btn:hover { background: #f0f0ff; }
        .mode-btn.active { background: #3949ab; color: white; }
        #searchInput { width: 100%; padding: 12px 16px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 16px; margin-bottom: 10px; }
        #searchInput:focus { outline: none; border-color: #3949ab; }
        .search-options { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; align-items: center; }
        .search-options label { font-size: 12px; color: #6c757d; margin-right: 5px; }
        .search-option { display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer; padding: 4px 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6; }
        .search-option:hover { background: #e9ecef; }
        .search-option input { margin: 0; cursor: pointer; }
        .search-option.active { background: #3949ab; color: white; border-color: #3949ab; }
        .search-targets { display: flex; flex-wrap: wrap; gap: 6px; margin-left: auto; }
        .search-target { font-size: 11px; padding: 3px 8px; background: #e9ecef; border-radius: 3px; cursor: pointer; }
        .search-target:hover { background: #dee2e6; }
        .search-target.active { background: #28a745; color: white; }
        .alphabet-nav { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 15px; }
        .alphabet-nav button { padding: 6px 10px; border: none; background: #e9ecef; border-radius: 4px; cursor: pointer; font-size: 13px; }
        .alphabet-nav button:hover { background: #3949ab; color: white; }
        .alphabet-nav button.active { background: #1a237e; color: white; }
        .filter-section { display: flex; flex-wrap: wrap; gap: 8px; }
        .filter-btn { padding: 6px 12px; border: none; background: #e9ecef; border-radius: 20px; cursor: pointer; font-size: 12px; }
        .filter-btn:hover { background: #dee2e6; }
        .filter-btn.active { background: #3949ab; color: white; }
        .stats { padding: 10px 30px; background: #fff3cd; font-size: 13px; color: #856404; }
        .dictionary-list { max-height: 60vh; overflow-y: auto; }
        .entry { padding: 20px 30px; border-bottom: 1px solid #e9ecef; }
        .entry:hover { background: #fafbfc; }
        .entry-header { display: flex; align-items: baseline; gap: 12px; margin-bottom: 8px; flex-wrap: wrap; }
        .morph { font-size: 26px; font-weight: bold; color: #1a1a2e; }
        .morph-index { font-size: 14px; color: #6c757d; vertical-align: super; }
        .pos-badge { padding: 3px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .gloss-main { font-size: 18px; color: #2d3436; }
        .entry-header.reverse .gloss-main { font-size: 24px; font-weight: bold; color: #1a1a2e; order: -1; }
        .entry-header.reverse .morph { font-size: 20px; color: #3949ab; }
        .allomorphs { font-size: 13px; color: #6c757d; margin: 8px 0; padding: 6px 10px; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #856404; }
        .allomorphs::before { content: "Áï∞ÂΩ¢ÊÖã: "; font-weight: bold; color: #856404; }
        .allomorph-item { display: inline-block; background: #e9ecef; padding: 2px 8px; border-radius: 3px; margin: 2px 3px 2px 0; font-family: monospace; font-size: 14px; }
        .examples-section { margin-top: 12px; padding-top: 12px; border-top: 1px dashed #dee2e6; }
        .examples-title { font-size: 12px; font-weight: bold; color: #6c757d; margin-bottom: 8px; }
        .example { margin-bottom: 12px; padding: 10px; background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%); border-radius: 8px; font-size: 13px; }
        .example-header { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
        .play-btn { width: 32px; height: 32px; border: none; border-radius: 50%; background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%); color: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; }
        .play-btn:hover { transform: scale(1.1); box-shadow: 0 3px 10px rgba(102,126,234,0.4); }
        .play-btn.playing { background: #e74c3c; }
        .example-text { font-size: 14px; color: #1a1a2e; line-height: 1.5; font-weight: 500; flex: 1; }
        .example-trans { font-size: 13px; color: #2d3436; margin-bottom: 8px; padding: 6px 10px; background: #fff; border-radius: 4px; border-left: 3px solid #3949ab; }
        .example-trans::before { content: "Ë®≥: "; font-weight: bold; color: #3949ab; }
        .interlinear { display: flex; flex-wrap: wrap; gap: 2px; font-family: 'Consolas', 'Monaco', monospace; padding-top: 8px; border-top: 1px solid #dee2e6; }
        .gloss-unit { display: flex; flex-direction: column; align-items: center; padding: 3px 5px; margin-right: 4px; border-radius: 3px; background: #fff; }
        .gloss-unit.target { background: #fff3cd; border: 2px solid #ffc107; }
        .gloss-unit .morph-text { font-size: 13px; color: #1a1a2e; font-weight: 500; }
        .gloss-unit .gloss-text { font-size: 10px; color: #6c757d; }
        .gloss-unit.target .morph-text { color: #856404; font-weight: bold; }
        .gloss-unit.target .gloss-text { color: #856404; }
        .pos-V { background: #cce5ff; color: #004085; } .pos-N { background: #d4edda; color: #155724; } .pos-AUX { background: #fff3cd; color: #856404; } .pos-ADJ { background: #f8d7da; color: #721c24; } .pos-ADV { background: #e2d5f1; color: #5a2d82; } .pos-PRN { background: #d1ecf1; color: #0c5460; } .pos-CONJ { background: #d4edda; color: #155724; } .pos-CP { background: #ffeaa7; color: #856404; } .pos-ISP { background: #dfe6e9; color: #2d3436; } .pos-SFP { background: #fab1a0; color: #6c3d00; } .pos-INTJ { background: #fd79a8; color: #6c1e3d; } .pos-VAFX { background: #74b9ff; color: #003366; } .pos-NAFX { background: #a29bfe; color: #2d1f5c; } .pos-FN { background: #81ecec; color: #006266; } .pos-PN { background: #ffeaa7; color: #6c5000; } .pos-NUM { background: #fdcb6e; color: #5a4000; } .pos-CJP { background: #00cec9; color: #006266; } .pos-LP { background: #a8e6cf; color: #1b5e20; } .pos-CLF { background: #b2bec3; color: #2d3436; } .pos-default { background: #e9ecef; color: #495057; }
        .no-results { padding: 40px; text-align: center; color: #6c757d; }
        footer { padding: 15px 30px; background: #f8f9fa; text-align: center; font-size: 12px; color: #6c757d; }
        .highlight { background: #fff3cd; padding: 0 2px; border-radius: 2px; }
        .csv-btn { padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; margin-left: 10px; }
        .csv-btn:hover { background: #218838; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèùÔ∏è ${escapeHtml(title)}</h1>
            ${subtitle ? `<p>${escapeHtml(subtitle)}</p>` : ''}
        </header>
        <div class="search-section">
            <div class="mode-toggle">
                <button class="mode-btn active" id="modeNormal">Ë¶ãÂá∫„ÅóÈ†ÜÔºàÂÆÆÂè§Ë™û‚ÜíÊÑèÂë≥Ôºâ</button>
                <button class="mode-btn" id="modeReverse">ÈÄÜÂºï„ÅçÔºàÊÑèÂë≥‚ÜíÂÆÆÂè§Ë™ûÔºâ</button>
            </div>
            <input type="text" id="searchInput" placeholder="ÂΩ¢ÊÖãÁ¥†„ÉªÊÑèÂë≥„ÉªÂìÅË©û„ÉªÂíåË®≥„ÇíÊ§úÁ¥¢...">
            <div class="search-options">
                <label>Ê§úÁ¥¢ÊñπÊ≥ï:</label>
                <span class="search-option active" data-mode="partial">ÈÉ®ÂàÜ‰∏ÄËá¥</span>
                <span class="search-option" data-mode="exact">ÂÆåÂÖ®‰∏ÄËá¥</span>
                <span class="search-option" data-mode="prefix">ÂâçÊñπ‰∏ÄËá¥</span>
                <span class="search-option" data-mode="suffix">ÂæåÊñπ‰∏ÄËá¥</span>
                <div class="search-targets">
                    <span class="search-target active" data-target="morph">ÂΩ¢ÊÖãÁ¥†</span>
                    <span class="search-target active" data-target="gloss">ÊÑèÂë≥</span>
                    <span class="search-target active" data-target="pos">ÂìÅË©û</span>
                    <span class="search-target active" data-target="trans">ÂíåË®≥</span>
                    <span class="search-target active" data-target="allo">Áï∞ÂΩ¢ÊÖã</span>
                </div>
            </div>
            <div class="alphabet-nav" id="alphabetNav"></div>
            <div class="filter-section" id="posFilters"></div>
        </div>
        <div class="stats" id="stats"></div>
        <div class="dictionary-list" id="dictionaryList"></div>
        <footer>${escapeHtml(title)} | Á∑èË¶ãÂá∫„ÅóË™ûÊï∞: <span id="totalCount">0</span>Ë™û | üîä ‰æãÊñá„Çí„ÇØ„É™„ÉÉ„ÇØ„ÅßÈü≥Â£∞ÂÜçÁîü <button class="csv-btn" onclick="downloadCSV()">üì• CSV„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</button></footer>
    </div>
<script>
const dictionaryData = ${dictJSON};
let currentFilter = null, currentLetter = null, searchQuery = '', reverseMode = false;
let searchMode = 'partial';
let searchTargets = { morph: true, gloss: true, pos: true, trans: true, allo: true };
let audioElements = {}, currentlyPlaying = null, preloadQueue = [], isPreloading = false;

// „Éó„É™„É≠„Éº„ÉâÊ©üËÉΩ
function preloadAudio(url) {
    if (!url || audioElements[url]) return;
    const audio = new Audio();
    audio.preload = 'auto';
    audioElements[url] = audio;
    audio.src = url;
}

function preloadAllAudio() {
    // ÂÖ®„Å¶„ÅÆÈü≥Â£∞URL„ÇíÂèéÈõÜ
    const urls = new Set();
    for (const entry of dictionaryData) {
        for (const ex of (entry.examples || [])) {
            if (ex.audio_file) urls.add(ex.audio_file);
        }
    }
    preloadQueue = [...urls];
    preloadNext();
}

function preloadNext() {
    if (preloadQueue.length === 0 || isPreloading) return;
    isPreloading = true;
    const url = preloadQueue.shift();
    if (!audioElements[url]) {
        const audio = new Audio();
        audio.preload = 'auto';
        audioElements[url] = audio;
        audio.oncanplaythrough = () => { isPreloading = false; preloadNext(); };
        audio.onerror = () => { isPreloading = false; preloadNext(); };
        audio.src = url;
        // 3Áßí„Åß„Çø„Ç§„É†„Ç¢„Ç¶„Éà
        setTimeout(() => { if (isPreloading) { isPreloading = false; preloadNext(); } }, 3000);
    } else {
        isPreloading = false;
        preloadNext();
    }
}

function loadAudio(f) { 
    if (!audioElements[f]) { 
        audioElements[f] = new Audio(f); 
        audioElements[f].preload = 'auto'; 
    } 
    return audioElements[f]; 
}

function playAudio(f, s, e, btn) {
    if (currentlyPlaying) { 
        currentlyPlaying.audio.pause(); 
        if (currentlyPlaying.button) { 
            currentlyPlaying.button.classList.remove('playing'); 
            currentlyPlaying.button.textContent = '‚ñ∂'; 
        } 
    }
    const audio = loadAudio(f);
    if (currentlyPlaying && currentlyPlaying.button === btn && !audio.paused) { 
        currentlyPlaying = null; 
        return; 
    }
    
    // „É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫
    btn.classList.add('playing'); 
    btn.textContent = '‚è≥';
    
    const startPlayback = () => {
        audio.currentTime = s; 
        btn.textContent = '‚èπ'; 
        currentlyPlaying = { audio, button: btn, endTime: e };
        const checkEnd = () => { 
            if (audio.currentTime >= e) { 
                audio.pause(); 
                btn.classList.remove('playing'); 
                btn.textContent = '‚ñ∂'; 
                currentlyPlaying = null; 
            } else if (currentlyPlaying?.audio === audio) {
                requestAnimationFrame(checkEnd); 
            }
        };
        audio.play().then(() => requestAnimationFrame(checkEnd)).catch(() => { 
            btn.classList.remove('playing'); 
            btn.textContent = '‚ñ∂'; 
        });
    };
    
    // Êó¢„Å´„É≠„Éº„ÉâÊ∏à„Åø„Å™„Çâ„Åô„ÅêÂÜçÁîü
    if (audio.readyState >= 3) {
        startPlayback();
    } else {
        audio.oncanplaythrough = startPlayback;
        audio.onerror = () => { btn.classList.remove('playing'); btn.textContent = '‚ùå'; };
    }
}

// „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂæå„Å´„Éó„É™„É≠„Éº„ÉâÈñãÂßã
setTimeout(preloadAllAudio, 1000);

const glossReading = {'‰∏ä„Åå„Çã':'„ÅÇ„Åå„Çã','Èñì':'„ÅÇ„ÅÑ„Å†','ÂÆ∂':'„ÅÑ„Åà','Ë°å„Åè':'„ÅÑ„Åè','Êµ∑':'„ÅÜ„Åø','„ÅäÊØç„Åï„Çì':'„Åä„Åã„ÅÇ„Åï„Çì','ËêΩ„Å°„Çã':'„Åä„Å°„Çã','Ê≤ñÁ∏Ñ':'„Åä„Åç„Å™„Çè','È°î':'„Åã„Åä','Â∏∞„Çã':'„Åã„Åà„Çã','Ë≤∑„ÅÜ':'„Åã„ÅÜ','Á•û':'„Åã„Åø','È´™':'„Åã„Åø','Êù•„Çã':'„Åè„Çã','È≠ö':'„Åï„Åã„Å™','Ê≠ª„Å¨':'„Åó„Å¨','Êâã':'„Å¶','ÊôÇ':'„Å®„Åç','ÂèãÈÅî':'„Å®„ÇÇ„Å†„Å°','‰∫∫':'„Å≤„Å®','Ëàπ':'„Åµ„Å≠','Êòî':'„ÇÄ„Åã„Åó','Ê∞¥':'„Åø„Åö','Áâ©':'„ÇÇ„ÅÆ','ÁÑº„Åè':'„ÇÑ„Åè','Ë±ÜËÖê':'„Å®„ÅÜ„Åµ','È£ü„Åπ„Çã':'„Åü„Åπ„Çã','Â§ß„Åç„ÅÑ':'„Åä„Åä„Åç„ÅÑ','Ë≤ß„Åó„ÅÑ':'„Åæ„Åö„Åó„ÅÑ','Ë±ä„Åã„Å™':'„ÇÜ„Åü„Åã„Å™'};
const gojuonRows = [{label:'„ÅÇ',chars:'„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Ç¢„Ç§„Ç¶„Ç®„Ç™'},{label:'„Åã',chars:'„Åã„Åç„Åè„Åë„Åì„Åå„Åé„Åê„Åí„Åî„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Ç¨„ÇÆ„Ç∞„Ç≤„Ç¥'},{label:'„Åï',chars:'„Åï„Åó„Åô„Åõ„Åù„Åñ„Åò„Åö„Åú„Åû„Çµ„Ç∑„Çπ„Çª„ÇΩ„Ç∂„Ç∏„Ç∫„Çº„Çæ'},{label:'„Åü',chars:'„Åü„Å°„Å§„Å¶„Å®„Å†„Å¢„Å•„Åß„Å©„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„ÉÄ„ÉÇ„ÉÖ„Éá„Éâ'},{label:'„Å™',chars:'„Å™„Å´„Å¨„Å≠„ÅÆ„Éä„Éã„Éå„Éç„Éé'},{label:'„ÅØ',chars:'„ÅØ„Å≤„Åµ„Å∏„Åª„Å∞„Å≥„Å∂„Åπ„Åº„Å±„Å¥„Å∑„Å∫„ÅΩ„Éè„Éí„Éï„Éò„Éõ„Éê„Éì„Éñ„Éô„Éú„Éë„Éî„Éó„Éö„Éù'},{label:'„Åæ',chars:'„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„Éû„Éü„É†„É°„É¢'},{label:'„ÇÑ',chars:'„ÇÑ„ÇÜ„Çà„É§„É¶„É®'},{label:'„Çâ',chars:'„Çâ„Çä„Çã„Çå„Çç„É©„É™„É´„É¨„É≠'},{label:'„Çè',chars:'„Çè„Çí„Çì„ÉØ„É≤„É≥'},{label:'‰ªñ',chars:''}];

function getGojuonRow(str) { if (!str) return '‰ªñ'; const r = glossReading[str], f = r ? r.charAt(0) : str.charAt(0); for (const row of gojuonRows) if (row.chars.includes(f)) return row.label; return '‰ªñ'; }
function getGojuonSortKey(str) { if (!str) return '„Çì999'; if (glossReading[str]) return glossReading[str]; const first = str.charAt(0); if ((first >= '„ÅÅ' && first <= '„Çì') || (first >= '„Ç°' && first <= '„É≥')) return str; return '„Çì999' + str; }
function getPosClass(pos) { const known = ['V','N','AUX','ADJ','ADV','PRN','CONJ','CP','ISP','SFP','INTJ','VAFX','NAFX','FN','PN','NUM','CLF','CJP','LP']; return known.includes(pos) ? 'pos-'+pos : 'pos-default'; }
function highlightText(text, q) { 
    if (!q || !text) return text || ''; 
    try { 
        const lower = text.toLowerCase();
        const qLower = q.toLowerCase();
        const idx = lower.indexOf(qLower);
        if (idx === -1) return text;
        return text.substring(0, idx) + '<span class="highlight">' + text.substring(idx, idx + q.length) + '</span>' + text.substring(idx + q.length);
    } catch(e) { return text; } 
}

function renderExample(ex) {
    const { morphs = [], glosses = [], trans, target_index, audio_file, start_time, end_time } = ex;
    const safeAudioFile = audio_file ? audio_file.replace(/'/g, "\\\\'") : '';
    let playBtn = (audio_file && start_time !== undefined) ? \`<button class="play-btn" onclick="playAudio('\${safeAudioFile}', \${start_time}, \${end_time}, this)">‚ñ∂</button>\` : '';
    const transHtml = trans ? \`<div class="example-trans">\${trans}</div>\` : '';
    let interlinear = '';
    for (let i = 0; i < morphs.length && i < glosses.length; i++) {
        const m = morphs[i], g = glosses[i]; if (!m || m === 'XXX') continue;
        interlinear += \`<div class="gloss-unit \${i === target_index ? 'target' : ''}"><span class="morph-text">\${m}</span><span class="gloss-text">\${g || '?'}</span></div>\`;
    }
    return \`<div class="example"><div class="example-header">\${playBtn}<div class="example-text">\${ex.text}</div></div>\${transHtml}<div class="interlinear">\${interlinear}</div></div>\`;
}

function renderEntry(item, q) {
    const posClass = getPosClass(item.pos), indexHtml = item.morph_index ? \`<span class="morph-index">\${item.morph_index}</span>\` : '';
    const headerClass = reverseMode ? 'entry-header reverse' : 'entry-header';
    const glossDisplay = reverseMode && item.glosses_all?.length > 1 ? item.glosses_all.join('„ÄÅ') : item.gloss;
    let allomorphsHtml = item.allomorphs?.length ? \`<div class="allomorphs">\${item.allomorphs.map(a => \`<span class="allomorph-item">\${a}</span>\`).join('')}</div>\` : '';
    let examplesHtml = '';
    if (item.examples?.length) {
        const tc = item.examples.filter(e => e.trans).length, ac = item.examples.filter(e => e.audio_file && e.start_time !== undefined).length;
        examplesHtml = \`<div class="examples-section"><div class="examples-title">üìñ Áî®‰æã \${item.examples.length}‰ª∂\${tc ? \`ÔºàÂíåË®≥\${tc}‰ª∂Ôºâ\` : ''}\${ac ? \` üîä\${ac}‰ª∂\` : ''}</div>\${item.examples.map(renderExample).join('')}</div>\`;
    }
    return \`<div class="entry"><div class="\${headerClass}"><span class="morph">\${highlightText(item.morph, q)}\${indexHtml}</span><span class="pos-badge \${posClass}">\${item.pos || '?'}</span><span class="gloss-main">\${highlightText(glossDisplay, q)}</span></div>\${allomorphsHtml}\${examplesHtml}</div>\`;
}

function getSortedData() {
    if (reverseMode) {
        const groups = new Map();
        for (const item of dictionaryData) {
            if (!groups.has(item.morph)) groups.set(item.morph, { morph: item.morph, glosses: [], pos: item.pos, allomorphs: new Set(), examples: [] });
            const g = groups.get(item.morph), base = item.gloss?.split('.')[0] || '';
            if (base && !g.glosses.includes(base)) g.glosses.push(base);
            (item.allomorphs || []).forEach(a => g.allomorphs.add(a));
            (item.examples || []).forEach(ex => { if (g.examples.length < 3 && !g.examples.some(e => e.text === ex.text)) g.examples.push(ex); });
        }
        return [...groups.values()].map(g => ({ morph: g.morph, gloss: g.glosses.sort((a, b) => getGojuonSortKey(a).localeCompare(getGojuonSortKey(b), 'ja'))[0] || '', glosses_all: g.glosses, pos: g.pos, allomorphs: [...g.allomorphs].sort(), examples: g.examples, morph_index: null })).sort((a, b) => getGojuonSortKey(a.gloss).localeCompare(getGojuonSortKey(b.gloss), 'ja'));
    }
    return [...dictionaryData].sort((a, b) => a.morph.toLowerCase().localeCompare(b.morph.toLowerCase()) || (a.pos || '').localeCompare(b.pos || ''));
}

function matchSearch(text, query, mode) {
    if (!text || !query) return false;
    const t = text.toLowerCase();
    const q = query.toLowerCase();
    switch(mode) {
        case 'exact': return t === q;
        case 'prefix': return t.startsWith(q);
        case 'suffix': return t.endsWith(q);
        default: return t.includes(q);
    }
}

function filterData() {
    return getSortedData().filter(item => {
        if (currentLetter) { 
            if (reverseMode) { 
                if (getGojuonRow(item.gloss) !== currentLetter) return false; 
            } else { 
                if (item.morph.charAt(0).toLowerCase() !== currentLetter.toLowerCase()) return false; 
            } 
        }
        if (currentFilter && item.pos !== currentFilter) return false;
        if (searchQuery) {
            let match = false;
            if (searchTargets.morph && matchSearch(item.morph, searchQuery, searchMode)) match = true;
            if (!match && searchTargets.gloss) {
                if (reverseMode && item.glosses_all) {
                    if (item.glosses_all.some(g => matchSearch(g, searchQuery, searchMode))) match = true;
                } else if (matchSearch(item.gloss, searchQuery, searchMode)) match = true;
            }
            if (!match && searchTargets.pos && matchSearch(item.pos, searchQuery, searchMode)) match = true;
            if (!match && searchTargets.allo && item.allomorphs?.some(a => matchSearch(a, searchQuery, searchMode))) match = true;
            if (!match && searchTargets.trans && item.examples?.some(ex => matchSearch(ex.trans, searchQuery, searchMode))) match = true;
            if (!match) return false;
        }
        return true;
    });
}

function render() {
    const list = document.getElementById('dictionaryList'), stats = document.getElementById('stats');
    const filtered = filterData();
    list.innerHTML = filtered.length === 0 ? '<div class="no-results">Ë©≤ÂΩì„Åô„ÇãË™û„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</div>' : filtered.map(item => renderEntry(item, searchQuery)).join('');
    const exCount = filtered.reduce((s, i) => s + (i.examples?.length || 0), 0), transCount = filtered.reduce((s, i) => s + (i.examples?.filter(e => e.trans).length || 0), 0), audioCount = filtered.reduce((s, i) => s + (i.examples?.filter(e => e.audio_file && e.start_time !== undefined).length || 0), 0);
    stats.textContent = \`\${reverseMode ? '„ÄêÈÄÜÂºï„Åç„Äë' : '„ÄêË¶ãÂá∫„ÅóÈ†Ü„Äë'} Ë°®Á§∫: \${filtered.length}Ë™ûÔºàÁî®‰æã: \${exCount}‰ª∂„ÄÅÂíåË®≥: \${transCount}‰ª∂„ÄÅÈü≥Â£∞: \${audioCount}‰ª∂Ôºâ\`;
}

function initAlphabetNav() {
    const nav = document.getElementById('alphabetNav'); nav.innerHTML = '';
    const allBtn = document.createElement('button'); allBtn.textContent = 'ÂÖ®„Å¶'; allBtn.className = 'active';
    allBtn.onclick = () => { currentLetter = null; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); allBtn.classList.add('active'); render(); };
    nav.appendChild(allBtn);
    if (reverseMode) {
        const used = new Set(dictionaryData.map(d => getGojuonRow(d.gloss)));
        gojuonRows.forEach(row => { if (used.has(row.label)) { const btn = document.createElement('button'); btn.textContent = row.label + 'Ë°å'; btn.onclick = () => { currentLetter = row.label; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; nav.appendChild(btn); } });
    } else {
        [...new Set(dictionaryData.map(d => d.morph.charAt(0).toLowerCase()))].sort().forEach(letter => { const btn = document.createElement('button'); btn.textContent = letter.toUpperCase(); btn.onclick = () => { currentLetter = letter; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; nav.appendChild(btn); });
    }
}

function initPosFilters() {
    const allPos = new Set(dictionaryData.map(d => d.pos).filter(Boolean)), filters = document.getElementById('posFilters'); filters.innerHTML = '';
    const allBtn = document.createElement('button'); allBtn.className = 'filter-btn active'; allBtn.textContent = 'ÂÖ®ÂìÅË©û';
    allBtn.onclick = () => { currentFilter = null; filters.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active')); allBtn.classList.add('active'); render(); };
    filters.appendChild(allBtn);
    ['V','N','ADJ','ADV','AUX','PRN','CP','ISP','SFP','INTJ','CONJ','VAFX','NAFX','FN','PN','CJP','LP'].forEach(pos => { if (allPos.has(pos)) { const btn = document.createElement('button'); btn.className = 'filter-btn'; btn.textContent = pos; btn.onclick = () => { currentFilter = pos; filters.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; filters.appendChild(btn); } });
}

document.getElementById('modeNormal').onclick = () => { reverseMode = false; document.getElementById('modeNormal').classList.add('active'); document.getElementById('modeReverse').classList.remove('active'); currentLetter = null; initAlphabetNav(); render(); };
document.getElementById('modeReverse').onclick = () => { reverseMode = true; document.getElementById('modeReverse').classList.add('active'); document.getElementById('modeNormal').classList.remove('active'); currentLetter = null; initAlphabetNav(); render(); };
document.getElementById('searchInput').oninput = (e) => { searchQuery = e.target.value; render(); };

// Ê§úÁ¥¢„É¢„Éº„ÉâÂàáÊõø
document.querySelectorAll('.search-option').forEach(opt => {
    opt.onclick = () => {
        document.querySelectorAll('.search-option').forEach(o => o.classList.remove('active'));
        opt.classList.add('active');
        searchMode = opt.dataset.mode;
        if (searchQuery) render();
    };
});

// Ê§úÁ¥¢ÂØæË±°ÂàáÊõø
document.querySelectorAll('.search-target').forEach(tgt => {
    tgt.onclick = () => {
        tgt.classList.toggle('active');
        searchTargets[tgt.dataset.target] = tgt.classList.contains('active');
        if (searchQuery) render();
    };
});

document.getElementById('totalCount').textContent = dictionaryData.length;
initAlphabetNav(); initPosFilters(); render();

function downloadCSV() {
    const escapeCSV = (str) => {
        if (!str) return '';
        str = String(str);
        if (str.includes(',') || str.includes('"') || str.includes('\\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    };
    
    // „Éò„ÉÉ„ÉÄ„Éº
    const headers = ['morph', 'pos', 'gloss', 'allomorphs', 'morph_index', 'ex_text', 'ex_trans', 'ex_morphs', 'ex_glosses', 'ex_audio', 'ex_start', 'ex_end', 'ex_target'];
    let csv = headers.join(',') + '\\n';
    
    for (const entry of dictionaryData) {
        const base = [
            escapeCSV(entry.morph),
            escapeCSV(entry.pos),
            escapeCSV(entry.gloss),
            escapeCSV((entry.allomorphs || []).join('|')),
            escapeCSV(entry.morph_index || '')
        ];
        
        if (entry.examples && entry.examples.length > 0) {
            for (const ex of entry.examples) {
                const row = [
                    ...base,
                    escapeCSV(ex.text),
                    escapeCSV(ex.trans),
                    escapeCSV((ex.morphs || []).join('|')),
                    escapeCSV((ex.glosses || []).join('|')),
                    escapeCSV(ex.audio_file),
                    escapeCSV(ex.start_time),
                    escapeCSV(ex.end_time),
                    escapeCSV(ex.target_index)
                ];
                csv += row.join(',') + '\\n';
            }
        } else {
            csv += base.join(',') + ',,,,,,,,' + '\\n';
        }
    }
    
    const bom = '\\uFEFF';
    const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'dictionary.csv';
    a.click();
    URL.revokeObjectURL(url);
}
<\/script>
</body>
</html>`;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// Event Handlers
// ============================================================================

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.onclick = () => fileInput.click();
dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
dropZone.ondragleave = () => dropZone.classList.remove('dragover');
dropZone.ondrop = (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
};

fileInput.onchange = (e) => handleFiles(e.target.files);

function handleFiles(files) {
    for (const file of files) {
        const reader = new FileReader();
        reader.onload = (e) => handleFile(file, e.target.result);
        reader.readAsText(file);
    }
    fileInput.value = '';
}

document.getElementById('btnGenerate').onclick = generateHTML;
document.getElementById('btnReload').onclick = reloadWithTierConfig;
</script>
</body>
</html>
