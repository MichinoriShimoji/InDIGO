<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InDIGO - Interactive Dictionary Generation Optimizer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif; 
            background: linear-gradient(135deg, #0d1b4c 0%, #1a237e 50%, #283593 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #0d1b4c 0%, #1a237e 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
        }
        header h1 { 
            font-size: 5rem; 
            font-weight: 800; 
            margin-bottom: 12px; 
            letter-spacing: 0.05em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        header p { opacity: 0.85; font-size: 16px; letter-spacing: 0.1em; }
        header .credits { 
            margin-top: 15px; 
            font-size: 13px; 
            opacity: 0.7; 
        }
        header a { 
            color: #90caf9; 
            text-decoration: none; 
        }
        header a:hover { 
            text-decoration: underline; 
        }
        
        .section {
            padding: 25px 30px;
            border-bottom: 1px solid #e9ecef;
        }
        .section h2 {
            font-size: 16px;
            color: #1a1a2e;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .section h2 .step {
            background: #3949ab;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .drop-zone {
            border: 2px dashed #3949ab;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8f9ff;
        }
        .drop-zone:hover { background: #eef0ff; border-color: #5a6fd6; }
        .drop-zone.dragover { background: #e0e5ff; border-color: #4a5fc6; }
        .drop-zone-icon { font-size: 48px; margin-bottom: 10px; }
        .drop-zone-text { color: #3949ab; font-size: 14px; }
        .drop-zone-text small { color: #6c757d; }
        
        #fileInput { display: none; }
        
        .loaded-files {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .file-tag {
            padding: 6px 12px;
            background: #d4edda;
            border: 1px solid #28a745;
            border-radius: 20px;
            font-size: 12px;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .file-tag .count {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
        }
        .file-tag .remove {
            cursor: pointer;
            color: #dc3545;
            font-weight: bold;
            margin-left: 4px;
        }
        .file-tag.csv-file {
            background: #cce5ff;
            border-color: #0d6efd;
            color: #004085;
        }
        .file-tag.csv-file .count {
            background: #0d6efd;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            font-size: 13px;
            color: #495057;
            margin-bottom: 6px;
        }
        .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
        }
        .input-group input:focus { outline: none; border-color: #3949ab; }
        .input-group small {
            display: block;
            margin-top: 6px;
            color: #6c757d;
            font-size: 12px;
        }
        
        .stats-box {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .stats-box h3 {
            font-size: 13px;
            color: #495057;
            margin-bottom: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #3949ab;
        }
        .stat-label {
            font-size: 11px;
            color: #6c757d;
        }
        
        .btn-generate {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-generate:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102,126,234,0.4); }
        .btn-generate:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .output-section {
            display: none;
            padding: 25px 30px;
            background: #d4edda;
        }
        .output-section.show { display: block; }
        .output-section h2 {
            color: #155724;
            margin-bottom: 15px;
        }
        .btn-download {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 28px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
        }
        .btn-download:hover { background: #218838; }
        
        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 15px;
            margin-top: 15px;
            font-size: 13px;
            color: #856404;
        }
        
        .debug-box {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .debug-box h3 {
            font-size: 13px;
            color: #0c5460;
            margin-bottom: 10px;
        }
        .debug-box pre {
            font-size: 11px;
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .tier-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        .tier-grid .input-group {
            margin-bottom: 0;
        }
        .tier-grid input {
            padding: 8px 12px;
            font-size: 13px;
        }
        
        .btn-reload {
            padding: 10px 20px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-reload:hover {
            background: #138496;
        }
        
        .audio-url-item {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .audio-url-item label {
            display: block;
            font-size: 13px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
        }
        .audio-url-item textarea {
            width: 100%;
            height: 120px;
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            resize: vertical;
        }
        .audio-url-item textarea:focus {
            outline: none;
            border-color: #3949ab;
        }
        .audio-url-item textarea::placeholder {
            color: #adb5bd;
            font-size: 11px;
        }
        .audio-url-item .url-count {
            font-size: 12px;
            color: #6c757d;
            margin-top: 6px;
        }
        .audio-url-item .url-count.has-urls {
            color: #28a745;
        }
        .audio-url-item .zenodo-input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .audio-url-item .zenodo-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 12px;
        }
        .audio-url-item .zenodo-input:focus {
            outline: none;
            border-color: #3949ab;
        }
        .audio-url-item .zenodo-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        .audio-url-item .zenodo-btn:hover {
            background: #138496;
        }
        .audio-url-item .zenodo-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .audio-url-item .zenodo-status {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 8px;
        }
        .audio-url-item .zenodo-status.error {
            color: #dc3545;
        }
        .audio-url-item .zenodo-status.success {
            color: #28a745;
        }
        
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .tier-config-item {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3949ab;
        }
        .tier-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .tier-config-header strong {
            font-size: 14px;
            color: #1a1a2e;
        }
        .tier-config-count {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
        }
        .tier-config-count.zero {
            color: #dc3545;
        }
        .tier-info-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        .tier-info-tag {
            font-size: 10px;
            padding: 2px 6px;
            background: #e9ecef;
            border-radius: 3px;
            color: #495057;
        }
        .tier-info-more {
            font-size: 10px;
            padding: 2px 6px;
            color: #6c757d;
        }
        .tier-config-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        .tier-select {
            display: flex;
            flex-direction: column;
        }
        .tier-select label {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 3px;
        }
        .tier-select select {
            padding: 6px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
            background: white;
        }
        .tier-select select:focus {
            outline: none;
            border-color: #3949ab;
        }
        
        @media (max-width: 600px) {
            .tier-config-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        footer {
            padding: 20px 30px;
            text-align: center;
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>InDIGO</h1>
            <p>Interactive Dictionary Generation Optimizer</p>
            <p class="credits">Â© Michinori Shimoji (<a href="https://mshimoji.com" target="_blank">mshimoji.com</a>) | DOI: <a href="https://doi.org/10.5281/zenodo.17769807" target="_blank">10.5281/zenodo.17769807</a></p>
        </header>
        
        <!-- Step 1: ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ -->
        <div class="section">
            <h2><span class="step">1</span> TXT/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-icon">ğŸ“</div>
                <div class="drop-zone-text">
                    ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—<br>
                    <small>ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠï¼ˆ.txt, .csv è¤‡æ•°å¯ï¼‰</small>
                </div>
            </div>
            <input type="file" id="fileInput" accept=".txt,.TXT,.csv,.CSV" multiple>
            <div class="loaded-files" id="loadedFiles"></div>
            
            <div class="stats-box" id="statsBox" style="display:none;">
                <h3>ğŸ“Š èª­ã¿è¾¼ã¿çµæœ</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="statFiles">0</div>
                        <div class="stat-label">ãƒ•ã‚¡ã‚¤ãƒ«</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSentences">0</div>
                        <div class="stat-label">æ–‡</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statEntries">0</div>
                        <div class="stat-label">è¦‹å‡ºã—èª</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Step 1.5: å±¤è¨­å®šï¼ˆTXTç”¨ï¼‰ -->
        <div class="section" id="txtLayerSection" style="display:none;">
            <h2><span class="step">1.5</span> å±¤æ§‹æˆã‚’è¨­å®š</h2>
            <p style="font-size:13px; color:#6c757d; margin-bottom:15px;">å„è¡ŒãŒã©ã®å±¤ã«å¯¾å¿œã™ã‚‹ã‹è¨­å®šã—ã¦ãã ã•ã„</p>
            <div id="txtLayerConfigList"></div>
            <button class="btn-reload" id="btnReloadTxt">ğŸ”„ å±¤è¨­å®šã‚’åæ˜ ã—ã¦å†èª­ã¿è¾¼ã¿</button>
        </div>
        
        <!-- Step 2: éŸ³å£°URLãƒªã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ -->
        <div class="section" id="audioSection" style="display:none;">
            <h2><span class="step">2</span> éŸ³å£°URLãƒªã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰</h2>
            <p style="font-size:13px; color:#6c757d; margin-bottom:15px;">
                Zenodoãƒ¬ã‚³ãƒ¼ãƒ‰URLã‚’å…¥åŠ›ã—ã¦ã€Œå–å¾—ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’è‡ªå‹•å–å¾—ã—ã¾ã™ã€‚<br>
                ã¾ãŸã¯ã€URLãƒªã‚¹ãƒˆã‚’ç›´æ¥è²¼ã‚Šä»˜ã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚æ–‡ç•ªå·é †ã«å¯¾å¿œã•ã›ã¦ãã ã•ã„ã€‚
            </p>
            <div id="audioUrlInputs"></div>
        </div>
        
        <!-- Step 3: è¾æ›¸æƒ…å ± -->
        <div class="section">
            <h2><span class="step">3</span> è¾æ›¸ã®æƒ…å ±ï¼ˆä»»æ„ï¼‰</h2>
            <div class="input-group">
                <label>è¾æ›¸ã‚¿ã‚¤ãƒˆãƒ«</label>
                <input type="text" id="titleInput" placeholder="å®®å¤èªè¾æ›¸" value="å®®å¤èªè¾æ›¸">
            </div>
            <div class="input-group">
                <label>ã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«</label>
                <input type="text" id="subtitleInput" placeholder="Miyako Language Dictionary" value="Miyako Language Dictionary">
            </div>
        </div>
        
        <!-- Step 3: ç”Ÿæˆ -->
        <div class="section">
            <h2><span class="step">4</span> HTMLã‚’ç”Ÿæˆ</h2>
            <button class="btn-generate" id="btnGenerate" disabled>
                ğŸ“„ è¾æ›¸HTMLã‚’ç”Ÿæˆ
            </button>
            <div class="info-box">
                ğŸ’¡ ç”Ÿæˆã•ã‚ŒãŸHTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’GitHub Pagesã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã ã‘ã§è¾æ›¸ãŒå…¬é–‹ã§ãã¾ã™ã€‚
            </div>
        </div>
        
        <!-- Output -->
        <div class="output-section" id="outputSection">
            <h2>âœ… ç”Ÿæˆå®Œäº†ï¼</h2>
            <a class="btn-download" id="downloadLink" href="#" download="miyako-dictionary.html">
                â¬‡ï¸ HTMLã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            </a>
        </div>
        
        <footer>
            InDIGO - Interactive Dictionary Generation Optimizer | TXT/CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ¤œç´¢å¯èƒ½ãªè¾æ›¸ã‚’ä½œæˆ
        </footer>
    </div>

<script>
// ============================================================================
// Dictionary Builder
// ============================================================================

class DictionaryBuilder {
    constructor(maxExamples = 3) {
        this.maxExamples = maxExamples;
        this.tokenFreq = new Map();
        this.allomorphToHead = new Map();
        this.entries = new Map();
        this.examplesByKey = new Map();
    }
    
    build(corpusItems) {
        this.tokenFreq.clear();
        this.allomorphToHead.clear();
        this.entries.clear();
        this.examplesByKey.clear();
        
        console.log('DictionaryBuilder: Processing', corpusItems.length, 'items');
        
        this._countTokens(corpusItems);
        console.log('DictionaryBuilder: Found', this.tokenFreq.size, 'unique tokens');
        
        this._findAllomorphs();
        this._createEntries();
        console.log('DictionaryBuilder: Created', this.entries.size, 'entries');
        
        this._collectExamples(corpusItems);
        this._assignMorphIndices();
        
        return this._toList();
    }
    
    // éŸ³éŸ»çš„ã«é¡ä¼¼ã—ãŸå­éŸ³ãƒšã‚¢ï¼ˆç½®æ›ã‚³ã‚¹ãƒˆ0ã¨ã—ã¦æ‰±ã†ï¼‰
    _areSimilarPhonemes(c1, c2) {
        if (c1 === c2) return true;
        const pairs = [
            ['k', 'f'],  // k â†” f
            ['t', 'c'],  // t â†” c
            ['g', 'v'],  // g â†” v
            ['p', 'h'],  // p â†” h ï¼ˆè¿½åŠ ï¼šå®®å¤èªã§ã‚ˆãã‚ã‚‹äº¤æ›¿ï¼‰
            ['o', 'u'],  // o â†” u ï¼ˆæ¯éŸ³äº¤æ›¿ï¼‰
            ['i', 'É¨'],  // i â†” É¨ ï¼ˆæ¯éŸ³äº¤æ›¿ï¼‰
        ];
        for (const [a, b] of pairs) {
            if ((c1 === a && c2 === b) || (c1 === b && c2 === a)) return true;
        }
        return false;
    }
    
    // éŸ³éŸ»é¡ä¼¼æ€§ã‚’è€ƒæ…®ã—ãŸç·¨é›†è·é›¢ã‚’è¨ˆç®—
    _levenshteinDistance(s1, s2, usePhonemeRules = false) {
        const m = s1.length, n = s2.length;
        if (m === 0) return n;
        if (n === 0) return m;
        
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                let cost;
                if (s1[i - 1] === s2[j - 1]) {
                    cost = 0;
                } else if (usePhonemeRules && this._areSimilarPhonemes(s1[i - 1], s2[j - 1])) {
                    cost = 0;  // éŸ³éŸ»çš„ã«é¡ä¼¼ã—ãŸç½®æ›ã¯ã‚³ã‚¹ãƒˆ0
                } else {
                    cost = 1;
                }
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,      // å‰Šé™¤
                    dp[i][j - 1] + 1,      // æŒ¿å…¥
                    dp[i - 1][j - 1] + cost // ç½®æ›
                );
            }
        }
        return dp[m][n];
    }
    
    // 2ã¤ã®å½¢æ…‹ç´ ãŒéŸ³å½¢çš„ã«é¡ä¼¼ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®š
    _areSimilar(morph1, morph2) {
        // å¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ã¦æ¯”è¼ƒ
        const strip = (s) => s.replace(/^[=~+\-.]/, '').toLowerCase();
        const m1 = strip(morph1);
        const m2 = strip(morph2);
        
        // åŒä¸€ãªã‚‰å½“ç„¶é¡ä¼¼
        if (m1 === m2) return true;
        
        // çŸ­ã„æ–¹ã¨é•·ã„æ–¹ã‚’ç‰¹å®š
        const shorter = m1.length <= m2.length ? m1 : m2;
        const longer = m1.length > m2.length ? m1 : m2;
        
        // 1æ–‡å­—ã®å½¢æ…‹ç´ ã¯åŸºæœ¬çš„ã«ç•°å½¢æ…‹ã«ã—ãªã„
        if (shorter.length === 1) {
            // é•·ã•ãŒåŒã˜ã§éŸ³éŸ»çš„ã«é¡ä¼¼ã™ã‚‹å ´åˆã®ã¿è¨±å¯
            if (longer.length === 1) {
                return this._areSimilarPhonemes(m1, m2);
            }
            return false;
        }
        
        // 2æ–‡å­—ã®å½¢æ…‹ç´ ã¯å³ã—ãåˆ¤å®š
        if (shorter.length === 2) {
            // é•·ã•ã®å·®ãŒ2ä»¥ä¸Šãªã‚‰ä¸å¯
            if (longer.length - shorter.length >= 2) return false;
            // éŸ³éŸ»é¡ä¼¼ã‚’è€ƒæ…®ã—ãŸç·¨é›†è·é›¢ãŒ1ä»¥å†…
            return this._levenshteinDistance(m1, m2, true) <= 1;
        }
        
        // 3æ–‡å­—ä»¥ä¸Šã®å½¢æ…‹ç´ 
        // éŸ³éŸ»é¡ä¼¼ã‚’è€ƒæ…®ã—ãŸç·¨é›†è·é›¢ã‚’è¨ˆç®—
        const distance = this._levenshteinDistance(m1, m2, true);
        
        // è¨±å®¹ã™ã‚‹ç·¨é›†è·é›¢ï¼šçŸ­ã„æ–¹ã®é•·ã•ã®50%ä»¥ä¸‹ï¼ˆæœ€ä½1ã€æœ€å¤§3ï¼‰
        const maxDistance = Math.max(1, Math.min(3, Math.floor(shorter.length * 0.5)));
        
        if (distance <= maxDistance) return true;
        
        // è¿½åŠ ãƒã‚§ãƒƒã‚¯ï¼šå…ˆé ­ãŒå…±é€šï¼ˆå°‘ãªãã¨ã‚‚2æ–‡å­—ä»¥ä¸Šï¼‰
        const minCommon = Math.min(2, shorter.length);
        if (m1.slice(0, minCommon) === m2.slice(0, minCommon)) {
            // å…ˆé ­ãŒå…±é€šã§ã€æœ«å°¾ã®é•ã„ãŒå°‘ãªã„å ´åˆï¼ˆæ¥å°¾è¾ã®é•ã„ï¼‰
            if (longer.length - shorter.length <= 2) return true;
        }
        
        // ä¸€æ–¹ãŒä»–æ–¹ã®éƒ¨åˆ†æ–‡å­—åˆ—ï¼ˆ3æ–‡å­—ä»¥ä¸Šã§ã€å…ˆé ­ã‹ã‚‰ä¸€è‡´ï¼‰
        if (shorter.length >= 3 && longer.startsWith(shorter)) return true;
        
        return false;
    }
    
    _countTokens(items) {
        for (const item of items) {
            const morphs = item.morphs || [];
            const glosses = item.gloss || [];
            const posList = item.pos || [];
            
            for (let i = 0; i < morphs.length; i++) {
                let m = morphs[i];
                const g = i < glosses.length ? glosses[i] : '';
                const p = i < posList.length ? posList[i] : '';  // posãŒç©ºã§ã‚‚OK
                
                // morphãŒç©ºã§glossãŒã‚ã‚‹å ´åˆã¯ã€glossã‚’è¦‹å‡ºã—èªã¨ã—ã¦ä½¿ç”¨
                // ä¾‹: textå±¤ã«å¢ƒç•ŒãŒãªãã€glosså±¤ãŒã€Œå­.DIM.NOMã€ã®å ´åˆ
                // morphs: ['ã£ãµããŒã¾ã¬', '', ''], glosses: ['å­', 'DIM', 'NOM']
                // â†’ DIMã€NOMã‚‚ã‚¨ãƒ³ãƒˆãƒªã¨ã—ã¦ç™»éŒ²
                if (!m && g) {
                    m = g;
                }
                
                if (m && m !== 'XXX' && g) {  // morphã¨glossãŒã‚ã‚Œã°ç™»éŒ²
                    const key = `${m}|${p}|${g}`;
                    this.tokenFreq.set(key, (this.tokenFreq.get(key) || 0) + 1);
                }
            }
        }
    }
    
    _findAllomorphs() {
        const groups = new Map();
        for (const [key, count] of this.tokenFreq) {
            const [morph, pos, gloss] = key.split('|');
            const gk = `${pos}|${gloss}`;
            if (!groups.has(gk)) groups.set(gk, []);
            groups.get(gk).push({ morph, count });
        }
        for (const [gk, morphs] of groups) {
            if (morphs.length > 1) {
                // é »åº¦é †ã«ã‚½ãƒ¼ãƒˆ
                morphs.sort((a, b) => b.count - a.count);
                const [pos, gloss] = gk.split('|');
                
                // éŸ³å½¢é¡ä¼¼æ€§ã«åŸºã¥ã„ã¦ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°
                // æœ€ã‚‚é »åº¦ã®é«˜ã„ã‚‚ã®ã‚’ä»£è¡¨å½¢ã®å€™è£œã¨ã—ã¦ã€é¡ä¼¼ã™ã‚‹ã‚‚ã®ã®ã¿ã‚’ç•°å½¢æ…‹ã¨ã™ã‚‹
                const processed = new Set();
                
                for (let i = 0; i < morphs.length; i++) {
                    if (processed.has(i)) continue;
                    
                    const head = morphs[i].morph;
                    processed.add(i);
                    
                    // ã“ã®headã«é¡ä¼¼ã™ã‚‹å½¢æ…‹ç´ ã‚’æ¢ã™
                    for (let j = i + 1; j < morphs.length; j++) {
                        if (processed.has(j)) continue;
                        
                        if (this._areSimilar(head, morphs[j].morph)) {
                            this.allomorphToHead.set(`${pos}|${gloss}|${morphs[j].morph}`, head);
                            processed.add(j);
                        }
                    }
                }
            }
        }
    }
    
    _createEntries() {
        for (const key of this.tokenFreq.keys()) {
            const [morph, pos, gloss] = key.split('|');
            const alloKey = `${pos}|${gloss}|${morph}`;
            if (this.allomorphToHead.has(alloKey)) {
                const head = this.allomorphToHead.get(alloKey);
                const entryKey = `${head}|${pos}|${gloss}`;
                if (!this.entries.has(entryKey)) this.entries.set(entryKey, { morph: head, pos, gloss, allomorphs: [] });
                this.entries.get(entryKey).allomorphs.push(morph);
            } else {
                if (!this.entries.has(key)) this.entries.set(key, { morph, pos, gloss, allomorphs: [] });
            }
        }
    }
    
    _collectExamples(items) {
        for (const item of items) {
            const { text, trans, morphs = [], gloss: glosses = [], pos: posList = [], start_time, end_time, _audio_file } = item;
            if (!text || !morphs.length) continue;
            const seen = new Set();
            for (let i = 0; i < morphs.length; i++) {
                let m = morphs[i];
                const g = i < glosses.length ? glosses[i] : '';
                const p = i < posList.length ? posList[i] : '';
                
                // morphãŒç©ºã§glossãŒã‚ã‚‹å ´åˆã¯ã€glossã‚’ä½¿ç”¨
                if (!m && g) {
                    m = g;
                }
                
                if (!m || m === 'XXX' || !g) continue;
                
                const alloKey = `${p}|${g}|${m}`;
                const head = this.allomorphToHead.get(alloKey) || m;
                const entryKey = `${head}|${p}|${g}`;
                if (!this.entries.has(entryKey) || seen.has(entryKey)) continue;
                seen.add(entryKey);
                if (!this.examplesByKey.has(entryKey)) this.examplesByKey.set(entryKey, []);
                this.examplesByKey.get(entryKey).push({
                    text, trans, morphs, glosses, pos_list: posList,
                    target_index: i, audio_file: _audio_file, start_time, end_time
                });
            }
        }
        for (const [key, entry] of this.entries) {
            const all = this.examplesByKey.get(key) || [];
            entry.examples = [...all.filter(e => e.trans), ...all.filter(e => !e.trans)].slice(0, this.maxExamples);
        }
    }
    
    _assignMorphIndices() {
        const counts = new Map();
        for (const e of this.entries.values()) counts.set(e.morph, (counts.get(e.morph) || 0) + 1);
        const indices = new Map();
        for (const key of [...this.entries.keys()].sort()) {
            const entry = this.entries.get(key);
            if (counts.get(entry.morph) > 1) {
                const idx = (indices.get(entry.morph) || 0) + 1;
                indices.set(entry.morph, idx);
                entry.morph_index = idx;
            } else {
                entry.morph_index = null;
            }
        }
    }
    
    _toList() {
        const result = [...this.entries.values()];
        result.forEach(e => e.allomorphs = [...new Set(e.allomorphs)].sort());
        result.sort((a, b) => a.morph.toLowerCase().localeCompare(b.morph.toLowerCase()) || (a.pos || '').localeCompare(b.pos || ''));
        return result;
    }
}

// ============================================================================
// Glossed Text Parser (ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼)
// ============================================================================

// TXTãƒ•ã‚¡ã‚¤ãƒ«ã®è¡Œæ•°ã‚’æ¤œå‡º
function detectTxtLineCount(content) {
    const lines = content.split(/\r?\n/);
    let currentLines = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const idMatch = line.match(/^\((\d+)\)$/);
        if (idMatch) {
            if (currentLines.length > 0) {
                return currentLines.length;
            }
            currentLines = [];
        } else if (line) {
            currentLines.push(line);
        }
    }
    return currentLines.length || 3;
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å±¤è¨­å®šã‚’è¿”ã™
function getDefaultLayerConfig(lineCount) {
    const layerOptions = ['text0', 'text', 'gloss', 'pos', 'trans'];
    let layers;
    
    switch (lineCount) {
        case 2:
            layers = ['text', 'gloss'];
            break;
        case 3:
            layers = ['text', 'gloss', 'trans'];
            break;
        case 4:
            layers = ['text', 'gloss', 'pos', 'trans'];
            break;
        case 5:
            layers = ['text0', 'text', 'gloss', 'pos', 'trans'];
            break;
        default:
            layers = ['text', 'gloss', 'trans'];
    }
    
    return { layers, lineCount };
}

function parseGlossedText(content, layerConfig) {
    const lines = content.split(/\r?\n/);
    const result = [];
    
    let currentId = null;
    let currentLines = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // æ–‡ç•ªå·ã®æ¤œå‡º: (1), (2), etc.
        const idMatch = line.match(/^\((\d+)\)$/);
        if (idMatch) {
            // å‰ã®æ–‡ã‚’å‡¦ç†
            if (currentId !== null && currentLines.length > 0) {
                const parsed = parseGlossedBlock(currentId, currentLines, layerConfig);
                if (parsed) result.push(parsed);
            }
            currentId = parseInt(idMatch[1]);
            currentLines = [];
        } else if (line && currentId !== null) {
            currentLines.push(line);
        }
    }
    
    // æœ€å¾Œã®æ–‡ã‚’å‡¦ç†
    if (currentId !== null && currentLines.length > 0) {
        const parsed = parseGlossedBlock(currentId, currentLines, layerConfig);
        if (parsed) result.push(parsed);
    }
    
    return result;
}

function parseGlossedBlock(id, lines, layerConfig) {
    // layerConfig.layers = ['text0', 'text', 'gloss', 'pos', 'trans'] ãªã©
    const layers = layerConfig?.layers || ['text', 'gloss', 'trans'];
    
    if (lines.length < 2) return null;
    
    // å„å±¤ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const layerData = {};
    for (let i = 0; i < layers.length && i < lines.length; i++) {
        layerData[layers[i]] = lines[i];
    }
    
    // text0ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’åŸæ–‡ã¨ã—ã¦ä½¿ç”¨ã€ãªã‘ã‚Œã°textã‚’ä½¿ç”¨
    const text0Line = layerData.text0 || '';
    const textLine = layerData.text || '';
    const glossLine = layerData.gloss || '';
    const posLine = layerData.pos || '';
    const transLine = layerData.trans || '';
    
    // è¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆã¯text0ãŒã‚ã‚Œã°ãã‚Œã‚’ã€ãªã‘ã‚Œã°textã‚’ä½¿ç”¨
    const displayText = text0Line || textLine;
    
    // ã‚¹ãƒšãƒ¼ã‚¹ã§å˜èªã«åˆ†å‰²ï¼ˆå½¢æ…‹ç´ è§£æã¯textå±¤ã‹ã‚‰ï¼‰
    const textWords = textLine.split(/\s+/).filter(w => w);
    const glossWords = glossLine.split(/\s+/).filter(w => w);
    const posWords = posLine ? posLine.split(/\s+/).filter(w => w) : [];
    
    // å…¨ã¦ã®å½¢æ…‹ç´ ã€ã‚°ãƒ­ã‚¹ã€å“è©ã‚’åé›†
    const allMorphs = [];
    const allGlosses = [];
    const allPos = [];
    
    // textå±¤ã®å˜èªæ•°ã‚’åŸºæº–ã«å‡¦ç†
    for (let i = 0; i < textWords.length; i++) {
        const textWord = textWords[i] || '';
        const glossWord = glossWords[i] || '';
        const posWord = posWords[i] || '';
        
        // textå±¤ã‹ã‚‰å½¢æ…‹ç´ ã‚’åˆ†å‰²ï¼ˆå¢ƒç•Œè¨˜å·ã‚’ä¿æŒï¼‰
        const morphParts = splitMorphemesWithBoundary(textWord);
        // glosså±¤ã¯å¢ƒç•Œè¨˜å·ä»˜ãã§åˆ†å‰²ï¼ˆåˆ¤å®šç”¨ï¼‰
        const glossPartsWithBoundary = splitMorphemesWithBoundary(glossWord);
        // gloss/poså±¤ã¯å¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ã¦åˆ†å‰²
        const glossParts = splitMorphemesNoBoundary(glossWord);
        const posParts = posWord ? splitMorphemesNoBoundary(posWord) : [];
        
        // textå±¤ã®å½¢æ…‹ç´ æ•°ã¨glosså±¤ã®å½¢æ…‹ç´ æ•°ã®å¤§ãã„æ–¹ã‚’åŸºæº–ã«ã™ã‚‹
        const maxParts = Math.max(morphParts.length, glossParts.length, posParts.length);
        
        for (let j = 0; j < maxParts; j++) {
            // textå±¤ã®å½¢æ…‹ç´ ãŒè¶³ã‚Šãªã„å ´åˆã¯ã€å˜èªå…¨ä½“ã‚’ä½¿ç”¨ï¼ˆæœ€åˆã®å½¢æ…‹ç´ ã®ã¿ï¼‰
            let morph = morphParts[j] || (j === 0 ? textWord : '');
            const gloss = glossParts[j] || '';
            const glossWithBoundary = glossPartsWithBoundary[j] || '';
            const pos = posParts[j] || '';
            
            // ã‚°ãƒ­ã‚¹ãŒæ—¥æœ¬èªã¾ãŸã¯å°æ–‡å­—è‹±èªã§å§‹ã¾ã‚‹å ´åˆã¯ã€å½¢æ…‹ç´ ã‹ã‚‰å¢ƒç•Œè¨˜å·ã‚’é™¤å»
            // ä¾‹: -namï¼ˆ-æ³¢ï¼‰â†’ namã€-wave â†’ wave
            // å¤§æ–‡å­—ã§å§‹ã¾ã‚‹å ´åˆã¯æ–‡æ³•ã‚°ãƒ­ã‚¹ï¼ˆä¾‹ï¼š-DIMï¼‰ãªã®ã§è¨˜å·ã‚’ä¿æŒ
            if (morph && glossWithBoundary) {
                const glossContent = glossWithBoundary.replace(/^[=\-~+.]/, '');
                if (glossContent && isLexicalGloss(glossContent)) {
                    // è¤‡åˆèªã®ä¸€éƒ¨ãªã®ã§è¨˜å·ã‚’é™¤å»
                    morph = morph.replace(/^[=\-~+.]/, '');
                }
            }
            
            // morphãŒç©ºã§ã‚‚glossã‚„posãŒã‚ã‚Œã°è¿½åŠ 
            if (morph || gloss || pos) {
                allMorphs.push(morph);
                allGlosses.push(gloss);
                if (posLine) {
                    allPos.push(pos);
                }
            }
        }
    }
    
    const result = {
        text: displayText,  // text0ãŒã‚ã‚Œã°text0ã€ãªã‘ã‚Œã°text
        morphs: allMorphs,
        gloss: allGlosses,
        trans: transLine,
        _sentence_id: id
    };
    
    // poså±¤ãŒã‚ã‚‹å ´åˆã®ã¿è¿½åŠ 
    if (allPos.length > 0) {
        result.pos = allPos;
    }
    
    return result;
}

// ã‚°ãƒ­ã‚¹ãŒèªå½™çš„ï¼ˆæ—¥æœ¬èªã¾ãŸã¯å°æ–‡å­—è‹±èªï¼‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
// èªå½™çš„ã‚°ãƒ­ã‚¹: æ³¢ã€waterã€å¤§ãã„ ãªã©
// æ–‡æ³•ã‚°ãƒ­ã‚¹: DIM, NOM, FOC ãªã©ï¼ˆå¤§æ–‡å­—ï¼‰
function isLexicalGloss(gloss) {
    if (!gloss) return false;
    const firstChar = gloss.charAt(0);
    // æ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªã€ã‚«ã‚¿ã‚«ãƒŠã€æ¼¢å­—ï¼‰
    if (/[ã-ã‚“ã‚¡-ãƒ³ä¸€-é¾¯]/.test(firstChar)) return true;
    // å°æ–‡å­—è‹±èª
    if (/[a-z]/.test(firstChar)) return true;
    return false;
}

// å½¢æ…‹ç´ ã‚’å¢ƒç•Œè¨˜å·ä»˜ãã§åˆ†å‰²
// å¢ƒç•Œè¨˜å·: = - ~ + .
// ä¾‹: bookuugoo-gama=u=du â†’ ['bookuugoo', '-gama', '=u', '=du']
// ä¾‹: æ˜”.HS â†’ ['æ˜”', '.HS']
function splitMorphemesWithBoundary(word) {
    if (!word) return [];
    
    const result = [];
    let current = '';
    let currentBoundary = '';
    
    for (let i = 0; i < word.length; i++) {
        const char = word[i];
        // ãƒ”ãƒªã‚ªãƒ‰ã¯å¢ƒç•Œè¨˜å·ã¨ã—ã¦æ‰±ã‚ãªã„ï¼ˆè¤‡åˆã‚°ãƒ­ã‚¹ NEG.SEQ ã®ãŸã‚ï¼‰
        if (char === '=' || char === '-' || char === '~' || char === '+') {
            if (current) {
                result.push(currentBoundary + current);
            }
            currentBoundary = char;
            current = '';
        } else {
            current += char;
        }
    }
    
    if (current) {
        result.push(currentBoundary + current);
    }
    
    return result;
}

// å½¢æ…‹ç´ ã‚’å¢ƒç•Œè¨˜å·ãªã—ã§åˆ†å‰²ï¼ˆgloss/posç”¨ï¼‰
// ä¾‹: æ˜”=FOC â†’ ['æ˜”', 'FOC']
// ä¾‹: NEG.SEQ â†’ ['NEG.SEQ'] ï¼ˆãƒ”ãƒªã‚ªãƒ‰ã¯åˆ†å‰²ã—ãªã„ã€è¤‡åˆã‚°ãƒ­ã‚¹ã®ãŸã‚ï¼‰
function splitMorphemesNoBoundary(word) {
    if (!word) return [];
    // ãƒ”ãƒªã‚ªãƒ‰ã¯å¢ƒç•Œè¨˜å·ã¨ã—ã¦æ‰±ã‚ãªã„ï¼ˆè¤‡åˆã‚°ãƒ­ã‚¹ NEG.SEQ ã®ãŸã‚ï¼‰
    return word.split(/[=\-~+]/).filter(p => p);
}

// æ¤œç´¢ç”¨ï¼šå¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ãŸå½¢æ…‹ç´ ã‚’è¿”ã™
function stripBoundary(morph) {
    if (!morph) return '';
    return morph.replace(/^[=~+\-.]/, '');
}

// ============================================================================
// CSV Parser
// ============================================================================

function parseCSV(content) {
    // BOMã‚’é™¤å»
    content = content.replace(/^\uFEFF/, '');
    
    const lines = content.split(/\r?\n/);
    if (lines.length < 2) throw new Error('CSVãŒç©ºã§ã™');
    
    // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’æ¢ã™ï¼ˆmorphã¨glossãŒå«ã¾ã‚Œã‚‹è¡Œï¼‰
    let headerLineIdx = -1;
    for (let i = 0; i < Math.min(lines.length, 10); i++) {
        const testHeaders = parseCSVLine(lines[i]);
        const testMap = {};
        testHeaders.forEach((h, idx) => testMap[h.toLowerCase().trim()] = idx);
        if (testMap['morph'] !== undefined && testMap['gloss'] !== undefined) {
            headerLineIdx = i;
            break;
        }
    }
    
    if (headerLineIdx === -1) {
        throw new Error('CSVã«ã¯ morph ã¨ gloss ã‚«ãƒ©ãƒ ãŒå¿…è¦ã§ã™');
    }
    
    // ãƒ˜ãƒƒãƒ€ãƒ¼è§£æ
    const headers = parseCSVLine(lines[headerLineIdx]);
    const headerMap = {};
    headers.forEach((h, i) => headerMap[h.toLowerCase().trim()] = i);
    
    const morphIdx = headerMap['morph'];
    const glossIdx = headerMap['gloss'];
    const posIdx = headerMap['pos'];
    const allomorphsIdx = headerMap['allomorphs'];
    const morphIndexIdx = headerMap['morph_index'];
    const exTextIdx = headerMap['ex_text'];
    const exTransIdx = headerMap['ex_trans'];
    const exMorphsIdx = headerMap['ex_morphs'];
    const exGlossesIdx = headerMap['ex_glosses'];
    const exAudioIdx = headerMap['ex_audio'];
    const exStartIdx = headerMap['ex_start'];
    const exEndIdx = headerMap['ex_end'];
    const exTargetIdx = headerMap['ex_target'];
    
    // ã‚¨ãƒ³ãƒˆãƒªã‚’ãƒãƒƒãƒ—ã§ç®¡ç†ï¼ˆåŒã˜morph+pos+glossã¯çµ±åˆï¼‰
    const entryMap = new Map();
    let exampleCount = 0;
    
    for (let i = headerLineIdx + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const cols = parseCSVLine(line);
        const morph = cols[morphIdx]?.trim() || '';
        const gloss = cols[glossIdx]?.trim() || '';
        if (!morph || !gloss) continue;
        
        const pos = posIdx !== undefined ? (cols[posIdx]?.trim() || '') : '';
        const key = `${morph}|${pos}|${gloss}`;
        
        if (!entryMap.has(key)) {
            const allomorphsStr = allomorphsIdx !== undefined ? (cols[allomorphsIdx]?.trim() || '') : '';
            const allomorphs = allomorphsStr ? allomorphsStr.split('|').map(s => s.trim()).filter(s => s) : [];
            const morphIndex = morphIndexIdx !== undefined ? (cols[morphIndexIdx]?.trim() || null) : null;
            
            entryMap.set(key, {
                morph,
                pos,
                gloss,
                allomorphs,
                morph_index: morphIndex ? parseInt(morphIndex) : null,
                examples: []
            });
        }
        
        // ç”¨ä¾‹ãŒã‚ã‚Œã°è¿½åŠ 
        const exText = exTextIdx !== undefined ? (cols[exTextIdx]?.trim() || '') : '';
        if (exText) {
            const entry = entryMap.get(key);
            const exMorphsStr = exMorphsIdx !== undefined ? (cols[exMorphsIdx]?.trim() || '') : '';
            const exGlossesStr = exGlossesIdx !== undefined ? (cols[exGlossesIdx]?.trim() || '') : '';
            const morphs = exMorphsStr ? exMorphsStr.split('|') : [];
            const glosses = exGlossesStr ? exGlossesStr.split('|') : [];
            
            // target_indexã®æ±ºå®šï¼šæŒ‡å®šãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°è‡ªå‹•æ¤œå‡º
            let targetIndex = undefined;
            const rawTarget = exTargetIdx !== undefined ? (cols[exTargetIdx]?.trim() || '') : '';
            // ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’é™¤å»ã—ã¦ãƒ‘ãƒ¼ã‚¹ï¼ˆExcelã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å¯¾ç­–ï¼‰
            const cleanTarget = rawTarget.replace(/^'/, '');
            if (cleanTarget && !isNaN(parseInt(cleanTarget))) {
                targetIndex = parseInt(cleanTarget);
            } else if (morphs.length > 0) {
                // è¦‹å‡ºã—èªã¾ãŸã¯ç•°å½¢æ…‹ã¨ä¸€è‡´ã™ã‚‹å½¢æ…‹ç´ ã‚’è‡ªå‹•æ¤œå‡ºï¼ˆå¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ã¦æ¯”è¼ƒï¼‰
                const stripBoundaryForCompare = (s) => s ? s.replace(/^[=~+\-.]/, '') : '';
                const morphBase = stripBoundaryForCompare(morph).toLowerCase();
                
                // ç•°å½¢æ…‹ãƒªã‚¹ãƒˆã‚’å–å¾—ï¼ˆæ—¢ã«entryã«è¿½åŠ æ¸ˆã¿ã®å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ï¼‰
                const allomorphsStr = allomorphsIdx !== undefined ? (cols[allomorphsIdx]?.trim() || '') : '';
                const allomorphs = allomorphsStr ? allomorphsStr.split('|').map(s => stripBoundaryForCompare(s.trim()).toLowerCase()) : [];
                
                for (let j = 0; j < morphs.length; j++) {
                    const morphToken = stripBoundaryForCompare(morphs[j]).toLowerCase();
                    // è¦‹å‡ºã—èªã¨ä¸€è‡´ã€ã¾ãŸã¯ç•°å½¢æ…‹ã®ã„ãšã‚Œã‹ã¨ä¸€è‡´
                    if (morphToken === morphBase || allomorphs.includes(morphToken)) {
                        targetIndex = j;
                        break;
                    }
                }
            }
            
            entry.examples.push({
                text: exText,
                trans: exTransIdx !== undefined ? (cols[exTransIdx]?.trim() || '') : '',
                morphs,
                glosses,
                audio_file: exAudioIdx !== undefined ? (cols[exAudioIdx]?.trim() || undefined) : undefined,
                start_time: exStartIdx !== undefined && cols[exStartIdx] ? parseFloat(cols[exStartIdx]) : undefined,
                end_time: exEndIdx !== undefined && cols[exEndIdx] ? parseFloat(cols[exEndIdx]) : undefined,
                target_index: targetIndex
            });
            exampleCount++;
        }
    }
    
    return {
        entries: [...entryMap.values()],
        exampleCount
    };
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (inQuotes) {
            if (char === '"') {
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = false;
                }
            } else {
                current += char;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
    }
    result.push(current);
    
    // Excelã§ä»˜ã‘ã‚‰ã‚ŒãŸå…ˆé ­ã®ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’é™¤å»
    return result.map(cell => cell.replace(/^'(?=[=+\-@])/, ''));
}

// ============================================================================
// State
// ============================================================================

let corpusData = [];
let loadedFiles = [];
let dictionaryData = [];
let rawTXTData = [];  // ç”Ÿã®TXTãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆå†ãƒ‘ãƒ¼ã‚¹ç”¨ï¼‰
let audioUrls = {};   // TXTãƒ•ã‚¡ã‚¤ãƒ«å â†’ URLãƒªã‚¹ãƒˆé…åˆ—
let txtLayerConfigs = {}; // TXTãƒ•ã‚¡ã‚¤ãƒ«å â†’ { layers: ['text', 'gloss', 'trans'], lineCount: 3 }
let csvDictionaryData = [];  // CSVã‹ã‚‰èª­ã¿è¾¼ã‚“ã è¾æ›¸ã‚¨ãƒ³ãƒˆãƒª

function updateTxtLayerConfigList() {
    const container = document.getElementById('txtLayerConfigList');
    const txtFiles = rawTXTData;
    
    if (txtFiles.length === 0) {
        document.getElementById('txtLayerSection').style.display = 'none';
        return;
    }
    
    document.getElementById('txtLayerSection').style.display = 'block';
    
    const layerOptions = ['text0', 'text', 'gloss', 'pos', 'trans'];
    
    container.innerHTML = txtFiles.map(({filename, content}) => {
        const config = txtLayerConfigs[filename] || getDefaultLayerConfig(detectTxtLineCount(content));
        txtLayerConfigs[filename] = config;
        
        // ã‚µãƒ³ãƒ—ãƒ«è¡Œã‚’å–å¾—ï¼ˆæœ€åˆã®æ–‡ã®å„è¡Œï¼‰
        const sampleLines = getSampleLines(content, config.lineCount);
        
        // å„è¡Œã®è¨­å®šUI
        const rowsHtml = [];
        for (let i = 0; i < config.lineCount; i++) {
            const currentLayer = config.layers[i] || 'text';
            const sampleText = sampleLines[i] || '';
            const truncatedSample = sampleText.length > 50 ? sampleText.substring(0, 50) + '...' : sampleText;
            
            const optionsHtml = layerOptions.map(opt => 
                `<option value="${opt}"${opt === currentLayer ? ' selected' : ''}>${opt}</option>`
            ).join('');
            
            rowsHtml.push(`
                <div class="txt-layer-row">
                    <span class="txt-layer-num">${i + 1}è¡Œç›®:</span>
                    <select class="txt-layer-select" data-file="${filename}" data-row="${i}">
                        ${optionsHtml}
                    </select>
                    <span class="txt-layer-sample">${escapeHtml(truncatedSample)}</span>
                </div>
            `);
        }
        
        return `
            <div class="txt-layer-config-item">
                <div class="txt-layer-header">
                    <strong>${filename}</strong>
                    <span class="tier-config-count" id="txt-count-${filename.replace(/[^a-zA-Z0-9]/g, '_')}">0æ–‡</span>
                </div>
                <div class="txt-layer-rows">${rowsHtml.join('')}</div>
            </div>
        `;
    }).join('');
    
    // ã‚¹ã‚¿ã‚¤ãƒ«è¿½åŠ 
    if (!document.getElementById('txtLayerStyles')) {
        const style = document.createElement('style');
        style.id = 'txtLayerStyles';
        style.textContent = `
            .txt-layer-config-item { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; }
            .txt-layer-header { display: flex; justify-content: space-between; margin-bottom: 10px; }
            .txt-layer-rows { display: flex; flex-direction: column; gap: 8px; }
            .txt-layer-row { display: flex; align-items: center; gap: 10px; }
            .txt-layer-num { font-weight: bold; color: #3949ab; min-width: 60px; }
            .txt-layer-select { padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; }
            .txt-layer-sample { font-size: 12px; color: #666; font-family: monospace; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 400px; }
        `;
        document.head.appendChild(style);
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¿½åŠ 
    container.querySelectorAll('.txt-layer-select').forEach(select => {
        select.onchange = (e) => {
            const file = e.target.dataset.file;
            const row = parseInt(e.target.dataset.row);
            if (!txtLayerConfigs[file]) txtLayerConfigs[file] = getDefaultLayerConfig(4);
            txtLayerConfigs[file].layers[row] = e.target.value;
        };
    });
}

function getSampleLines(content, lineCount) {
    const lines = content.split(/\r?\n/);
    const result = [];
    let inBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const idMatch = line.match(/^\((\d+)\)$/);
        if (idMatch) {
            if (result.length > 0) break; // æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã¿
            inBlock = true;
        } else if (line && inBlock) {
            result.push(line);
            if (result.length >= lineCount) break;
        }
    }
    return result;
}

async function fetchZenodoFiles(recordUrl, fileName) {
    // Zenodoã®ãƒ¬ã‚³ãƒ¼ãƒ‰URLã‹ã‚‰ãƒ¬ã‚³ãƒ¼ãƒ‰IDã‚’æŠ½å‡º
    // ä¾‹: https://zenodo.org/records/16675643 â†’ 16675643
    const match = recordUrl.match(/zenodo\.org\/records\/(\d+)/);
    if (!match) {
        throw new Error('ç„¡åŠ¹ãªZenodo URLã§ã™ã€‚ä¾‹: https://zenodo.org/records/12345678');
    }
    
    const recordId = match[1];
    const apiUrl = `https://zenodo.org/api/records/${recordId}`;
    
    // CORSãƒ—ãƒ­ã‚­ã‚·ã‚’è©¦è¡Œï¼ˆè¤‡æ•°ã®ãƒ—ãƒ­ã‚­ã‚·ã‚’é †ç•ªã«è©¦ã™ï¼‰
    const proxyUrls = [
        apiUrl, // ã¾ãšç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã‚’è©¦ã¿ã‚‹
        `https://corsproxy.io/?${encodeURIComponent(apiUrl)}`,
        `https://api.allorigins.win/get?url=${encodeURIComponent(apiUrl)}`,
        `https://thingproxy.freeboard.io/fetch/${apiUrl}`,
        `https://cors.bridged.cc/${apiUrl}`
    ];
    
    let data = null;
    let lastError = null;
    
    for (const url of proxyUrls) {
        try {
            console.log('Trying:', url);
            const response = await fetch(url);
            if (response.ok) {
                let jsonData = await response.json();
                // alloriginsã¯contentsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹
                if (jsonData.contents) {
                    jsonData = JSON.parse(jsonData.contents);
                }
                data = jsonData;
                console.log('Success with:', url);
                break;
            }
        } catch (e) {
            lastError = e;
            console.log(`Proxy failed: ${url}`, e.message);
        }
    }
    
    if (!data) {
        throw new Error('Zenodo APIã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚CORSãƒ—ãƒ­ã‚­ã‚·ãŒã™ã¹ã¦åˆ©ç”¨ä¸å¯ã§ã™ã€‚');
    }
    
    if (!data.files || data.files.length === 0) {
        throw new Error('ã“ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“');
    }
    
    // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const audioExtensions = ['.wav', '.mp3', '.ogg', '.flac', '.m4a'];
    const audioFiles = data.files.filter(f => {
        const ext = f.key.toLowerCase().substring(f.key.lastIndexOf('.'));
        return audioExtensions.includes(ext);
    });
    
    if (audioFiles.length === 0) {
        throw new Error('éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆ.wav, .mp3ãªã©ï¼‰');
    }
    
    // å€‹åˆ¥éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’æŠ½å‡ºï¼ˆ001_, 002_ãªã©ã§å§‹ã¾ã‚‹ã‚‚ã®ï¼‰
    // text_ã‚„fullãªã©ã®å…¨ä½“éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã¯é™¤å¤–
    const individualFiles = audioFiles.filter(f => {
        const filename = f.key;
        // æ•°å­—3æ¡_ã§å§‹ã¾ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¯å€‹åˆ¥éŸ³å£°
        if (/^\d{3}_/.test(filename)) {
            return true;
        }
        // text_ã§å§‹ã¾ã‚‹ã€ã¾ãŸã¯ "full" ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã¯é™¤å¤–
        if (/^text_/i.test(filename) || /full/i.test(filename)) {
            return false;
        }
        // ç•ªå·ãŒå«ã¾ã‚Œãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚é™¤å¤–
        if (!/\d{3}/.test(filename)) {
            return false;
        }
        return true;
    });
    
    // ãƒ•ã‚¡ã‚¤ãƒ«åã§ã‚½ãƒ¼ãƒˆï¼ˆ001_, 002_ãªã©ã®ç•ªå·é †ï¼‰
    individualFiles.sort((a, b) => a.key.localeCompare(b.key, undefined, { numeric: true }));
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰URLã‚’ç”Ÿæˆ
    const urls = individualFiles.map(f => f.links.self + '?download=1');
    
    return urls;
}

function updateAudioUrlList() {
    const container = document.getElementById('audioUrlInputs');
    const txtFiles = loadedFiles.filter(f => f.type === 'txt');
    
    if (txtFiles.length === 0) {
        document.getElementById('audioSection').style.display = 'none';
        return;
    }
    
    document.getElementById('audioSection').style.display = 'block';
    
    container.innerHTML = txtFiles.map(f => {
        const urls = audioUrls[f.name] || [];
        const urlText = urls.join('\n');
        const urlCount = urls.length;
        
        return `
            <div class="audio-url-item" data-file="${f.name}">
                <label><strong>${f.name}</strong> (${f.count}æ–‡)</label>
                <div class="zenodo-input-row">
                    <input type="text" 
                           class="zenodo-input" 
                           data-file="${f.name}"
                           placeholder="Zenodoãƒ¬ã‚³ãƒ¼ãƒ‰URLï¼ˆä¾‹: https://zenodo.org/records/16675643ï¼‰">
                    <button class="zenodo-btn" data-file="${f.name}">ğŸ“¥ å–å¾—</button>
                </div>
                <div class="zenodo-status" data-file="${f.name}"></div>
                <textarea 
                    class="audio-url-textarea" 
                    data-file="${f.name}"
                    placeholder="ã¾ãŸã¯ç›´æ¥URLãƒªã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘..."
                >${urlText}</textarea>
                <div class="url-count ${urlCount > 0 ? 'has-urls' : ''}" data-file="${f.name}">
                    ${urlCount > 0 ? `âœ… ${urlCount}ä»¶ã®URL` : 'ğŸ“‹ Zenodoãƒ¬ã‚³ãƒ¼ãƒ‰URLã‚’å…¥åŠ›ã™ã‚‹ã‹ã€URLãƒªã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„'}
                </div>
            </div>
        `;
    }).join('');
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å¤‰æ›´ã‚’ç›£è¦–
    container.querySelectorAll('.audio-url-textarea').forEach(textarea => {
        textarea.oninput = (e) => {
            const fileName = e.target.dataset.file;
            const text = e.target.value;
            const urls = text.trim().split('\n').map(u => u.trim()).filter(u => u && u.startsWith('http'));
            
            audioUrls[fileName] = urls;
            
            const countEl = container.querySelector(`.url-count[data-file="${fileName}"]`);
            if (countEl) {
                countEl.textContent = urls.length > 0 ? `âœ… ${urls.length}ä»¶ã®URL` : 'ğŸ“‹ Zenodoãƒ¬ã‚³ãƒ¼ãƒ‰URLã‚’å…¥åŠ›ã™ã‚‹ã‹ã€URLãƒªã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„';
                countEl.className = 'url-count' + (urls.length > 0 ? ' has-urls' : '');
            }
        };
    });
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: Zenodoå–å¾—ãƒœã‚¿ãƒ³
    container.querySelectorAll('.zenodo-btn').forEach(btn => {
        btn.onclick = async (e) => {
            const fileName = e.target.dataset.file;
            const input = container.querySelector(`.zenodo-input[data-file="${fileName}"]`);
            const textarea = container.querySelector(`.audio-url-textarea[data-file="${fileName}"]`);
            const status = container.querySelector(`.zenodo-status[data-file="${fileName}"]`);
            const countEl = container.querySelector(`.url-count[data-file="${fileName}"]`);
            
            const recordUrl = input.value.trim();
            if (!recordUrl) {
                status.textContent = 'âŒ Zenodoãƒ¬ã‚³ãƒ¼ãƒ‰URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                status.className = 'zenodo-status error';
                return;
            }
            
            // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            btn.disabled = true;
            btn.textContent = 'â³ å–å¾—ä¸­...';
            status.textContent = 'Zenodo APIã«æ¥ç¶šä¸­...';
            status.className = 'zenodo-status';
            
            try {
                const urls = await fetchZenodoFiles(recordUrl, fileName);
                
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«è¨­å®š
                textarea.value = urls.join('\n');
                audioUrls[fileName] = urls;
                
                status.textContent = `âœ… ${urls.length}ä»¶ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã—ãŸ`;
                status.className = 'zenodo-status success';
                
                countEl.textContent = `âœ… ${urls.length}ä»¶ã®URL`;
                countEl.className = 'url-count has-urls';
                
            } catch (err) {
                status.textContent = 'âŒ ' + err.message;
                status.className = 'zenodo-status error';
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ“¥ å–å¾—';
            }
        };
    });
}

// ============================================================================
// File Handling
// ============================================================================

function detectFileType(data) {
    if (Array.isArray(data) && data.length > 0) {
        const first = data[0];
        if (first.morph && first.gloss && first.examples) return 'dictionary';
        if (first.text && (first.morphs || first.gloss)) return 'corpus';
    }
    return 'unknown';
}

function handleFile(file, content) {
    const filename = file.name;
    
    if (filename.toLowerCase().endsWith('.csv')) {
        try {
            const result = parseCSV(content);
            if (result.entries.length > 0) {
                // CSVã‹ã‚‰dictionaryDataã«ç›´æ¥è¿½åŠ ï¼ˆã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨˜éŒ²ï¼‰
                for (const entry of result.entries) {
                    entry._source_file = filename;
                }
                csvDictionaryData.push(...result.entries);
                loadedFiles.push({ name: filename, count: result.entries.length, baseName: filename.replace(/\.csv$/i, ''), type: 'csv' });
                console.log(`Loaded CSV: ${filename} (${result.entries.length} entries, ${result.exampleCount} examples)`);
            } else {
                alert(`CSVã«ã‚¨ãƒ³ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${filename}`);
            }
        } catch (err) {
            console.error(err);
            alert(`CSVãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${filename}\n${err.message}`);
        }
    } else if (filename.toLowerCase().endsWith('.txt')) {
        // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚°ãƒ­ã‚¹ä»˜ããƒ†ã‚­ã‚¹ãƒˆå½¢å¼ï¼‰ã®ãƒ‘ãƒ¼ã‚¹
        try {
            // ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            rawTXTData.push({ filename, content });
            
            // è¡Œæ•°ã‚’æ¤œå‡ºã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å±¤è¨­å®šã‚’ä½œæˆ
            if (!txtLayerConfigs[filename]) {
                const lineCount = detectTxtLineCount(content);
                txtLayerConfigs[filename] = getDefaultLayerConfig(lineCount);
                console.log(`Auto-detected layer config for ${filename}:`, txtLayerConfigs[filename]);
            }
            
            // å±¤è¨­å®šã«åŸºã¥ã„ã¦ãƒ‘ãƒ¼ã‚¹
            const layerConfig = txtLayerConfigs[filename];
            const result = parseGlossedText(content, layerConfig);
            
            if (result.length > 0) {
                const baseName = filename.replace(/\.txt$/i, '');
                for (const item of result) {
                    item._base_name = baseName;
                    item._source_file = filename;
                    corpusData.push(item);
                }
                loadedFiles.push({ name: filename, count: result.length, baseName, type: 'txt' });
                console.log(`Loaded TXT: ${filename} (${result.length} sentences)`);
                if (result.length > 0) {
                    console.log('Sample:', result[0]);
                }
            } else {
                alert(`ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«æ–‡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${filename}`);
            }
        } catch (err) {
            console.error(err);
            alert(`ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${filename}\n${err.message}`);
        }
    } else {
        alert(`æœªå¯¾å¿œã®ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™: ${filename}\n.txt ã¾ãŸã¯ .csv ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚`);
    }
    
    updateUI();
}

function reloadWithTxtLayerConfig() {
    // TXTãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’å†ãƒ‘ãƒ¼ã‚¹
    // CSVãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒ
    const csvLoadedFiles = loadedFiles.filter(f => f.type === 'csv');
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
    corpusData = [];
    loadedFiles = [...csvLoadedFiles];
    
    console.log('Reloading TXT with layer configs:', JSON.stringify(txtLayerConfigs));
    
    // ä¿å­˜ã—ãŸTXTãƒ‡ãƒ¼ã‚¿ã‚’å†ãƒ‘ãƒ¼ã‚¹
    for (const { filename, content } of rawTXTData) {
        const layerConfig = txtLayerConfigs[filename] || getDefaultLayerConfig(detectTxtLineCount(content));
        const result = parseGlossedText(content, layerConfig);
        const baseName = filename.replace(/\.txt$/i, '');
        
        console.log(`Re-parsed ${filename}: ${result.length} sentences with config:`, layerConfig);
        
        for (const item of result) {
            item._base_name = baseName;
            item._source_file = filename;
            corpusData.push(item);
        }
        
        loadedFiles.push({ name: filename, count: result.length, baseName, type: 'txt' });
    }
    
    updateUI();
    
    // ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤ºã‚’æ›´æ–°
    for (const f of loadedFiles) {
        if (f.type === 'txt') {
            const countEl = document.getElementById(`txt-count-${f.name.replace(/[^a-zA-Z0-9]/g, '_')}`);
            if (countEl) {
                countEl.textContent = `${f.count}æ–‡`;
                countEl.className = f.count > 0 ? 'tier-config-count' : 'tier-config-count zero';
            }
        }
    }
}

function updateUI() {
    // Update file tags
    const filesEl = document.getElementById('loadedFiles');
    filesEl.innerHTML = loadedFiles.map((f, i) => `
        <span class="file-tag ${f.type === 'csv' ? 'csv-file' : ''}">
            ${f.name}
            <span class="count">${f.count}${f.type === 'csv' ? 'ã‚¨ãƒ³ãƒˆãƒª' : 'æ–‡'}</span>
            <span class="remove" onclick="removeFile(${i})">âœ•</span>
        </span>
    `).join('');
    
    // Update TXT layer config list
    updateTxtLayerConfigList();
    
    // Update audio URL list
    updateAudioUrlList();
    
    // Build dictionary
    const hasCorpus = corpusData.length > 0;
    const hasCSV = csvDictionaryData.length > 0;
    
    if (hasCorpus || hasCSV) {
        // ã‚³ãƒ¼ãƒ‘ã‚¹ã‹ã‚‰è¾æ›¸ã‚’æ§‹ç¯‰
        let builtDict = [];
        if (hasCorpus) {
            const builder = new DictionaryBuilder(3);
            builtDict = builder.build(corpusData);
        }
        
        // CSVã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ
        if (hasCSV) {
            dictionaryData = mergeDictionaries(builtDict, csvDictionaryData);
        } else {
            dictionaryData = builtDict;
        }
        
        const totalSentences = corpusData.length + csvDictionaryData.reduce((sum, e) => sum + (e.examples?.length || 0), 0);
        
        document.getElementById('statsBox').style.display = 'block';
        document.getElementById('statFiles').textContent = loadedFiles.length;
        document.getElementById('statSentences').textContent = totalSentences;
        document.getElementById('statEntries').textContent = dictionaryData.length;
        document.getElementById('btnGenerate').disabled = false;
    } else {
        document.getElementById('statsBox').style.display = 'none';
        document.getElementById('btnGenerate').disabled = true;
        dictionaryData = [];
    }
}

function mergeDictionaries(dict1, dict2) {
    const merged = new Map();
    
    // dict1ã‚’è¿½åŠ 
    for (const entry of dict1) {
        const key = `${entry.morph}|${entry.pos}|${entry.gloss}`;
        merged.set(key, { ...entry });
    }
    
    // dict2ã‚’è¿½åŠ ï¼ˆæ—¢å­˜ã‚¨ãƒ³ãƒˆãƒªã¯ç”¨ä¾‹ã‚’ãƒãƒ¼ã‚¸ï¼‰
    for (const entry of dict2) {
        const key = `${entry.morph}|${entry.pos}|${entry.gloss}`;
        if (merged.has(key)) {
            const existing = merged.get(key);
            // ç•°å½¢æ…‹ã‚’ãƒãƒ¼ã‚¸
            const allAllomorphs = new Set([...(existing.allomorphs || []), ...(entry.allomorphs || [])]);
            existing.allomorphs = [...allAllomorphs].sort();
            // ç”¨ä¾‹ã‚’ãƒãƒ¼ã‚¸ï¼ˆé‡è¤‡ã‚’é¿ã‘ã¦æœ€å¤§3ä»¶ï¼‰
            const existingTexts = new Set((existing.examples || []).map(e => e.text));
            for (const ex of (entry.examples || [])) {
                if (!existingTexts.has(ex.text) && (existing.examples || []).length < 3) {
                    existing.examples = existing.examples || [];
                    existing.examples.push(ex);
                }
            }
        } else {
            merged.set(key, { ...entry });
        }
    }
    
    // ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã™
    return [...merged.values()].sort((a, b) => 
        a.morph.toLowerCase().localeCompare(b.morph.toLowerCase()) || 
        (a.pos || '').localeCompare(b.pos || '')
    );
}

function removeFile(index) {
    const file = loadedFiles[index];
    
    if (file.type === 'csv') {
        // CSVãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã€è©²å½“ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
        csvDictionaryData = csvDictionaryData.filter(item => item._source_file !== file.name);
    } else if (file.type === 'txt') {
        corpusData = corpusData.filter(item => item._source_file !== file.name);
        rawTXTData = rawTXTData.filter(item => item.filename !== file.name);
        delete audioUrls[file.name];
        delete txtLayerConfigs[file.name];
    }
    
    loadedFiles.splice(index, 1);
    
    updateUI();
}

// ============================================================================
// HTML Generation
// ============================================================================

function generateHTML() {
    const title = document.getElementById('titleInput').value || 'å®®å¤èªè¾æ›¸';
    const subtitle = document.getElementById('subtitleInput').value || '';
    
    // ãƒ‡ãƒãƒƒã‚°: corpusDataã®ç¢ºèª
    console.log('=== Generate HTML Debug ===');
    console.log('corpusData length:', corpusData.length);
    if (corpusData.length > 0) {
        console.log('Sample corpus item:', JSON.stringify(corpusData[0], null, 2));
    }
    console.log('dictionaryData length:', dictionaryData.length);
    if (dictionaryData.length > 0) {
        console.log('Sample dictionary entry:', JSON.stringify(dictionaryData[0], null, 2));
    }
    
    // è¾æ›¸ãŒç©ºã®å ´åˆã¯å†æ§‹ç¯‰ã‚’è©¦ã¿ã‚‹
    if (dictionaryData.length === 0 && corpusData.length > 0) {
        console.log('Dictionary is empty, rebuilding...');
        const builder = new DictionaryBuilder(3);
        dictionaryData = builder.build(corpusData);
        console.log('Rebuilt dictionary length:', dictionaryData.length);
    }
    
    // éŸ³å£°URLã‚’examplesã«è¨­å®š
    console.log('audioUrls:', JSON.stringify(audioUrls));
    let audioSetCount = 0;
    
    // å„ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®æ–‡ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ—ã‚’ä½œæˆ
    const fileIndexMaps = {};
    const fileSentenceIdMaps = {};
    for (const item of corpusData) {
        const sf = item._source_file;
        if (!fileIndexMaps[sf]) fileIndexMaps[sf] = [];
        if (!fileSentenceIdMaps[sf]) fileSentenceIdMaps[sf] = {};
        fileIndexMaps[sf].push(item.text);
        // _sentence_idãŒã‚ã‚‹å ´åˆï¼ˆTXTãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã¯è¨˜éŒ²
        if (item._sentence_id !== undefined) {
            fileSentenceIdMaps[sf][item.text] = item._sentence_id;
        }
    }
    
    for (const entry of dictionaryData) {
        for (const ex of (entry.examples || [])) {
            if (ex.audio_file === undefined) {
                // corpusDataã‹ã‚‰å…ƒã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¦‹ã¤ã‘ã‚‹
                const corpusItem = corpusData.find(c => c.text === ex.text);
                if (corpusItem && corpusItem._source_file) {
                    const urls = audioUrls[corpusItem._source_file];
                    if (urls && urls.length > 0) {
                        let urlIndex = -1;
                        
                        // _sentence_idãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ã†ï¼ˆ1å§‹ã¾ã‚Š â†’ 0å§‹ã¾ã‚Šã«å¤‰æ›ï¼‰
                        if (corpusItem._sentence_id !== undefined) {
                            urlIndex = corpusItem._sentence_id - 1;
                        } else {
                            // ãªã‘ã‚Œã°æ–‡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†
                            urlIndex = fileIndexMaps[corpusItem._source_file].indexOf(ex.text);
                        }
                        
                        if (urlIndex >= 0 && urlIndex < urls.length) {
                            ex.audio_file = urls[urlIndex];
                            ex.start_time = 0;  // ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’å†ç”Ÿ
                            ex.end_time = 0;
                            audioSetCount++;
                        }
                    }
                }
            }
        }
    }
    console.log('Audio URLs set for', audioSetCount, 'examples');
    
    // å†ç¢ºèªï¼šéŸ³å£°URLãŒè¨­å®šã•ã‚ŒãŸexamplesã®æ•°
    let hasAudioCount = 0;
    for (const entry of dictionaryData) {
        for (const ex of (entry.examples || [])) {
            if (ex.audio_file) {
                hasAudioCount++;
            }
        }
    }
    console.log('Examples with audio:', hasAudioCount);
    
    if (dictionaryData.length === 0) {
        alert('è¾æ›¸ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚\n\nãƒ‡ãƒãƒƒã‚°æƒ…å ±:\n- corpusData: ' + corpusData.length + 'ä»¶\n- æœ€åˆã®æ–‡ã®morphs: ' + JSON.stringify(corpusData[0]?.morphs) + '\n- æœ€åˆã®æ–‡ã®gloss: ' + JSON.stringify(corpusData[0]?.gloss));
        return;
    }
    
    const html = generateDictionaryHTML(title, subtitle, dictionaryData);
    
    // Create download link
    const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const downloadLink = document.getElementById('downloadLink');
    downloadLink.href = url;
    downloadLink.download = 'miyako-dictionary.html';
    
    document.getElementById('outputSection').classList.add('show');
    downloadLink.scrollIntoView({ behavior: 'smooth' });
}

function generateDictionaryHTML(title, subtitle, dictionary) {
    // JSONå†…ã®å±é™ºãªæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    const dictJSON = JSON.stringify(dictionary)
        .replace(/</g, '\\u003c')
        .replace(/>/g, '\\u003e')
        .replace(/&/g, '\\u0026')
        .replace(/'/g, '\\u0027');
    
    return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${escapeHtml(title)}</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif; background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 950px; margin: 0 auto; background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; padding: 30px; text-align: center; }
        header h1 { font-size: 28px; margin-bottom: 8px; }
        header p { opacity: 0.8; font-size: 14px; }
        .search-section { padding: 20px 30px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; }
        .mode-toggle { display: flex; gap: 0; margin-bottom: 15px; border-radius: 8px; overflow: hidden; border: 2px solid #3949ab; }
        .mode-btn { flex: 1; padding: 10px 20px; border: none; background: white; cursor: pointer; font-size: 14px; font-weight: bold; color: #3949ab; transition: all 0.2s; }
        .mode-btn:hover { background: #f0f0ff; }
        .mode-btn.active { background: #3949ab; color: white; }
        #searchInput { width: 100%; padding: 12px 16px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 16px; margin-bottom: 10px; }
        #searchInput:focus { outline: none; border-color: #3949ab; }
        .search-options { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; align-items: center; }
        .search-options label { font-size: 12px; color: #6c757d; margin-right: 5px; }
        .search-option { display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer; padding: 4px 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6; }
        .search-option:hover { background: #e9ecef; }
        .search-option input { margin: 0; cursor: pointer; }
        .search-option.active { background: #3949ab; color: white; border-color: #3949ab; }
        .search-targets { display: flex; flex-wrap: wrap; gap: 6px; margin-left: auto; }
        .search-target { font-size: 11px; padding: 3px 8px; background: #e9ecef; border-radius: 3px; cursor: pointer; }
        .search-target:hover { background: #dee2e6; }
        .search-target.active { background: #28a745; color: white; }
        .alphabet-nav { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 15px; }
        .alphabet-nav button { padding: 6px 10px; border: none; background: #e9ecef; border-radius: 4px; cursor: pointer; font-size: 13px; }
        .alphabet-nav button:hover { background: #3949ab; color: white; }
        .alphabet-nav button.active { background: #1a237e; color: white; }
        .filter-section { display: flex; flex-wrap: wrap; gap: 8px; }
        .filter-btn { padding: 6px 12px; border: none; background: #e9ecef; border-radius: 20px; cursor: pointer; font-size: 12px; }
        .filter-btn:hover { background: #dee2e6; }
        .filter-btn.active { background: #3949ab; color: white; }
        .stats { padding: 10px 30px; background: #fff3cd; font-size: 13px; color: #856404; }
        .dictionary-list { max-height: 60vh; overflow-y: auto; }
        .entry { padding: 20px 30px; border-bottom: 1px solid #e9ecef; }
        .entry:hover { background: #fafbfc; }
        .entry-header { display: flex; align-items: baseline; gap: 12px; margin-bottom: 8px; flex-wrap: wrap; }
        .morph { font-size: 26px; font-weight: bold; color: #1a1a2e; }
        .morph-index { font-size: 14px; color: #6c757d; vertical-align: super; }
        .pos-badge { padding: 3px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .gloss-main { font-size: 18px; color: #2d3436; }
        .entry-header.reverse .gloss-main { font-size: 24px; font-weight: bold; color: #1a1a2e; order: -1; }
        .entry-header.reverse .morph { font-size: 20px; color: #3949ab; }
        .allomorphs { font-size: 13px; color: #6c757d; margin: 8px 0; padding: 6px 10px; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #856404; }
        .allomorphs::before { content: "ç•°å½¢æ…‹: "; font-weight: bold; color: #856404; }
        .allomorph-item { display: inline-block; background: #e9ecef; padding: 2px 8px; border-radius: 3px; margin: 2px 3px 2px 0; font-family: monospace; font-size: 14px; }
        .allomorph-link { cursor: pointer; background: #d4edda; border: 1px solid #28a745; color: #155724; }
        .allomorph-link:hover { background: #c3e6cb; }
        .examples-section { margin-top: 12px; padding-top: 12px; border-top: 1px dashed #dee2e6; }
        .examples-title { font-size: 12px; font-weight: bold; color: #6c757d; margin-bottom: 8px; }
        .example { margin-bottom: 12px; padding: 10px; background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%); border-radius: 8px; font-size: 13px; }
        .example-header { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
        .play-btn { width: 32px; height: 32px; border: none; border-radius: 50%; background: linear-gradient(135deg, #3949ab 0%, #1a237e 100%); color: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; }
        .play-btn:hover { transform: scale(1.1); box-shadow: 0 3px 10px rgba(102,126,234,0.4); }
        .play-btn.playing { background: #e74c3c; }
        .example-text { font-size: 14px; color: #1a1a2e; line-height: 1.5; font-weight: 500; flex: 1; }
        .example-trans { font-size: 13px; color: #2d3436; margin-bottom: 8px; padding: 6px 10px; background: #fff; border-radius: 4px; border-left: 3px solid #3949ab; }
        .example-trans::before { content: "è¨³: "; font-weight: bold; color: #3949ab; }
        .interlinear { display: flex; flex-wrap: wrap; gap: 2px; font-family: 'Consolas', 'Monaco', monospace; padding-top: 8px; border-top: 1px solid #dee2e6; }
        .gloss-unit { display: flex; flex-direction: column; align-items: center; padding: 3px 5px; margin-right: 4px; border-radius: 3px; background: #fff; }
        .gloss-unit.target { background: #fff3cd; border: 2px solid #ffc107; }
        .gloss-unit .morph-text { font-size: 13px; color: #1a1a2e; font-weight: 500; }
        .gloss-unit .gloss-text { font-size: 10px; color: #6c757d; }
        .gloss-unit.target .morph-text { color: #856404; font-weight: bold; }
        .gloss-unit.target .gloss-text { color: #856404; }
        .pos-V { background: #cce5ff; color: #004085; } .pos-N { background: #d4edda; color: #155724; } .pos-AUX { background: #fff3cd; color: #856404; } .pos-ADJ { background: #f8d7da; color: #721c24; } .pos-ADV { background: #e2d5f1; color: #5a2d82; } .pos-PRN { background: #d1ecf1; color: #0c5460; } .pos-CONJ { background: #d4edda; color: #155724; } .pos-CP { background: #ffeaa7; color: #856404; } .pos-ISP { background: #dfe6e9; color: #2d3436; } .pos-SFP { background: #fab1a0; color: #6c3d00; } .pos-INTJ { background: #fd79a8; color: #6c1e3d; } .pos-VAFX { background: #74b9ff; color: #003366; } .pos-NAFX { background: #a29bfe; color: #2d1f5c; } .pos-FN { background: #81ecec; color: #006266; } .pos-PN { background: #ffeaa7; color: #6c5000; } .pos-NUM { background: #fdcb6e; color: #5a4000; } .pos-CJP { background: #00cec9; color: #006266; } .pos-LP { background: #a8e6cf; color: #1b5e20; } .pos-CLF { background: #b2bec3; color: #2d3436; } .pos-default { background: #e9ecef; color: #495057; }
        .no-results { padding: 40px; text-align: center; color: #6c757d; }
        footer { padding: 15px 30px; background: #f8f9fa; text-align: center; font-size: 12px; color: #6c757d; }
        .highlight { background: #fff3cd; padding: 0 2px; border-radius: 2px; }
        .csv-btn { padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; margin-left: 10px; }
        .csv-btn:hover { background: #218838; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸï¸ ${escapeHtml(title)}</h1>
            ${subtitle ? `<p>${escapeHtml(subtitle)}</p>` : ''}
        </header>
        <div class="search-section">
            <div class="mode-toggle">
                <button class="mode-btn active" id="modeNormal">è¦‹å‡ºã—é †ï¼ˆå®®å¤èªâ†’æ„å‘³ï¼‰</button>
                <button class="mode-btn" id="modeReverse">é€†å¼•ãï¼ˆæ„å‘³â†’å®®å¤èªï¼‰</button>
            </div>
            <input type="text" id="searchInput" placeholder="å½¢æ…‹ç´ ãƒ»æ„å‘³ãƒ»å“è©ãƒ»å’Œè¨³ã‚’æ¤œç´¢...">
            <div class="search-options">
                <label>æ¤œç´¢æ–¹æ³•:</label>
                <span class="search-option active" data-mode="partial">éƒ¨åˆ†ä¸€è‡´</span>
                <span class="search-option" data-mode="exact">å®Œå…¨ä¸€è‡´</span>
                <span class="search-option" data-mode="prefix">å‰æ–¹ä¸€è‡´</span>
                <span class="search-option" data-mode="suffix">å¾Œæ–¹ä¸€è‡´</span>
                <div class="search-targets">
                    <span class="search-target active" data-target="morph">å½¢æ…‹ç´ </span>
                    <span class="search-target active" data-target="gloss">æ„å‘³</span>
                    <span class="search-target active" data-target="pos">å“è©</span>
                    <span class="search-target active" data-target="trans">å’Œè¨³</span>
                    <span class="search-target active" data-target="allo">ç•°å½¢æ…‹</span>
                </div>
            </div>
            <div class="alphabet-nav" id="alphabetNav"></div>
            <div class="filter-section" id="posFilters"></div>
        </div>
        <div class="stats" id="stats"></div>
        <div class="dictionary-list" id="dictionaryList"></div>
        <footer>${escapeHtml(title)} | ç·è¦‹å‡ºã—èªæ•°: <span id="totalCount">0</span>èª | ğŸ”Š ä¾‹æ–‡ã‚’ã‚¯ãƒªãƒƒã‚¯ã§éŸ³å£°å†ç”Ÿ <button class="csv-btn" onclick="downloadCSV()">ğŸ“¥ CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button></footer>
        <audio id="mainAudio" style="display:none;"></audio>
    </div>
<script>
const dictionaryData = ${dictJSON};
let currentFilter = null, currentLetter = null, searchQuery = '', reverseMode = false;
let searchMode = 'partial';
let searchTargets = { morph: true, gloss: true, pos: true, trans: true, allo: true };
let currentlyPlaying = null;

// éŸ³å£°ã‚’å†ç”Ÿ
async function playAudio(url, startTime, endTime, btn) {
    const audio = document.getElementById('mainAudio');
    
    // LaTeXã‚¹ã‚¿ã‚¤ãƒ«ã®UTFã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’å¤‰æ›
    // ä¾‹: \UTF{0268} â†’ É¨
    url = url.replace(/\\UTF\{([0-9A-Fa-f]+)\}/g, (match, hex) => {
        return String.fromCodePoint(parseInt(hex, 16));
    });
    
    // æ—¢ã«å†ç”Ÿä¸­ã®å ´åˆã¯åœæ­¢
    if (currentlyPlaying && currentlyPlaying.button === btn && !audio.paused) {
        audio.pause();
        btn.classList.remove('playing');
        btn.textContent = 'â–¶';
        currentlyPlaying = null;
        return;
    }
    
    // å‰ã®å†ç”Ÿã‚’åœæ­¢
    if (currentlyPlaying) {
        audio.pause();
        if (currentlyPlaying.button) {
            currentlyPlaying.button.classList.remove('playing');
            currentlyPlaying.button.textContent = 'â–¶';
        }
    }
    
    btn.classList.add('playing');
    btn.textContent = 'â³';
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’å†ç”Ÿã™ã‚‹ã‹ã€ç¯„å›²å†ç”Ÿã™ã‚‹ã‹ã‚’åˆ¤å®š
    const playFullFile = (!startTime && !endTime) || (startTime === 0 && endTime === 0);
    
    // å†ç”Ÿçµ‚äº†ãƒã‚§ãƒƒã‚¯ï¼ˆç¯„å›²å†ç”Ÿã®å ´åˆã®ã¿ï¼‰
    const checkEnd = () => {
        if (!playFullFile && audio.currentTime >= endTime) {
            audio.pause();
            btn.classList.remove('playing');
            btn.textContent = 'â–¶';
            currentlyPlaying = null;
        } else if (currentlyPlaying && currentlyPlaying.button === btn && !audio.paused) {
            requestAnimationFrame(checkEnd);
        }
    };
    
    // å†ç”Ÿçµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“å†ç”Ÿã®å ´åˆï¼‰
    const onEnded = () => {
        btn.classList.remove('playing');
        btn.textContent = 'â–¶';
        currentlyPlaying = null;
        audio.removeEventListener('ended', onEnded);
    };
    
    // å†ç”Ÿé–‹å§‹
    const startPlay = async (finalUrl) => {
        audio.pause();
        audio.currentTime = 0;
        audio.src = finalUrl;
        
        if (playFullFile) {
            audio.addEventListener('ended', onEnded);
        }
        
        try {
            await audio.play();
            if (!playFullFile) {
                audio.currentTime = startTime;
                requestAnimationFrame(checkEnd);
            }
            btn.textContent = 'â¹';
            currentlyPlaying = { button: btn, endTime };
            return true;
        } catch (error) {
            console.log('Play failed:', error.name, error.message);
            audio.removeEventListener('ended', onEnded);
            return false;
        }
    };
    
    // ç›´æ¥URLã§è©¦ã™
    if (await startPlay(url)) return;
    
    // CORSãƒ—ãƒ­ã‚­ã‚·ã‚’è©¦ã™
    console.log('Trying CORS proxy...');
    if (await startPlay('https://corsproxy.io/?' + encodeURIComponent(url))) return;
    
    // åˆ¥ã®ãƒ—ãƒ­ã‚­ã‚·ã‚’è©¦ã™
    console.log('Trying alternative proxy...');
    if (await startPlay('https://api.allorigins.win/raw?url=' + encodeURIComponent(url))) return;
    
    // å…¨ã¦å¤±æ•—
    console.log('All attempts failed');
    btn.classList.remove('playing');
    btn.textContent = 'âŒ';
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å¾Œã«ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰é–‹å§‹
// éŸ³å£°ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã¯å‰Šé™¤ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«å¤‰æ›´ï¼‰

const glossReading = {'ä¸ŠãŒã‚‹':'ã‚ãŒã‚‹','é–“':'ã‚ã„ã ','å®¶':'ã„ãˆ','è¡Œã':'ã„ã','æµ·':'ã†ã¿','ãŠæ¯ã•ã‚“':'ãŠã‹ã‚ã•ã‚“','è½ã¡ã‚‹':'ãŠã¡ã‚‹','æ²–ç¸„':'ãŠããªã‚','é¡”':'ã‹ãŠ','å¸°ã‚‹':'ã‹ãˆã‚‹','è²·ã†':'ã‹ã†','ç¥':'ã‹ã¿','é«ª':'ã‹ã¿','æ¥ã‚‹':'ãã‚‹','é­š':'ã•ã‹ãª','æ­»ã¬':'ã—ã¬','æ‰‹':'ã¦','æ™‚':'ã¨ã','å‹é”':'ã¨ã‚‚ã ã¡','äºº':'ã²ã¨','èˆ¹':'ãµã­','æ˜”':'ã‚€ã‹ã—','æ°´':'ã¿ãš','ç‰©':'ã‚‚ã®','ç„¼ã':'ã‚„ã','è±†è…':'ã¨ã†ãµ','é£Ÿã¹ã‚‹':'ãŸã¹ã‚‹','å¤§ãã„':'ãŠãŠãã„','è²§ã—ã„':'ã¾ãšã—ã„','è±Šã‹ãª':'ã‚†ãŸã‹ãª'};
const gojuonRows = [{label:'ã‚',chars:'ã‚ã„ã†ãˆãŠã‚¢ã‚¤ã‚¦ã‚¨ã‚ª'},{label:'ã‹',chars:'ã‹ããã‘ã“ãŒããã’ã”ã‚«ã‚­ã‚¯ã‚±ã‚³ã‚¬ã‚®ã‚°ã‚²ã‚´'},{label:'ã•',chars:'ã•ã—ã™ã›ãã–ã˜ãšãœãã‚µã‚·ã‚¹ã‚»ã‚½ã‚¶ã‚¸ã‚ºã‚¼ã‚¾'},{label:'ãŸ',chars:'ãŸã¡ã¤ã¦ã¨ã ã¢ã¥ã§ã©ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰'},{label:'ãª',chars:'ãªã«ã¬ã­ã®ãƒŠãƒ‹ãƒŒãƒãƒ'},{label:'ã¯',chars:'ã¯ã²ãµã¸ã»ã°ã³ã¶ã¹ã¼ã±ã´ã·ãºã½ãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ'},{label:'ã¾',chars:'ã¾ã¿ã‚€ã‚ã‚‚ãƒãƒŸãƒ ãƒ¡ãƒ¢'},{label:'ã‚„',chars:'ã‚„ã‚†ã‚ˆãƒ¤ãƒ¦ãƒ¨'},{label:'ã‚‰',chars:'ã‚‰ã‚Šã‚‹ã‚Œã‚ãƒ©ãƒªãƒ«ãƒ¬ãƒ­'},{label:'ã‚',chars:'ã‚ã‚’ã‚“ãƒ¯ãƒ²ãƒ³'},{label:'ä»–',chars:''}];

function getGojuonRow(str) { if (!str) return 'ä»–'; const r = glossReading[str], f = r ? r.charAt(0) : str.charAt(0); for (const row of gojuonRows) if (row.chars.includes(f)) return row.label; return 'ä»–'; }
function getGojuonSortKey(str) { if (!str) return 'ã‚“999'; if (glossReading[str]) return glossReading[str]; const first = str.charAt(0); if ((first >= 'ã' && first <= 'ã‚“') || (first >= 'ã‚¡' && first <= 'ãƒ³')) return str; return 'ã‚“999' + str; }
function getPosClass(pos) { const known = ['V','N','AUX','ADJ','ADV','PRN','CONJ','CP','ISP','SFP','INTJ','VAFX','NAFX','FN','PN','NUM','CLF','CJP','LP']; return known.includes(pos) ? 'pos-'+pos : 'pos-default'; }
function highlightText(text, q) { 
    if (!q || !text) return text || ''; 
    try { 
        const lower = text.toLowerCase();
        const qLower = q.toLowerCase();
        const idx = lower.indexOf(qLower);
        if (idx === -1) return text;
        return text.substring(0, idx) + '<span class="highlight">' + text.substring(idx, idx + q.length) + '</span>' + text.substring(idx + q.length);
    } catch(e) { return text; } 
}

function renderExample(ex) {
    const { morphs = [], glosses = [], trans, target_index, audio_file, start_time, end_time } = ex;
    const safeAudioFile = audio_file ? audio_file.replace(/'/g, "\\\\'") : '';
    let playBtn = audio_file ? \`<button class="play-btn" onclick="playAudio('\${safeAudioFile}', \${start_time || 0}, \${end_time || 0}, this)">â–¶</button>\` : '';
    const transHtml = trans ? \`<div class="example-trans">\${trans}</div>\` : '';
    let interlinear = '';
    for (let i = 0; i < morphs.length && i < glosses.length; i++) {
        const m = morphs[i], g = glosses[i]; if (!m || m === 'XXX') continue;
        interlinear += \`<div class="gloss-unit \${i === target_index ? 'target' : ''}"><span class="morph-text">\${m}</span><span class="gloss-text">\${g}</span></div>\`;
    }
    return \`<div class="example"><div class="example-header">\${playBtn}<div class="example-text">\${ex.text}</div></div><div class="interlinear">\${interlinear}</div>\${transHtml}</div>\`;
}

// æ¤œç´¢ç”¨ï¼šå¢ƒç•Œè¨˜å·ã‚’é™¤å»ï¼ˆheadwordSetã‚ˆã‚Šå‰ã«å®šç¾©ï¼‰
function stripBoundary(text) {
    if (!text) return '';
    return text.replace(/^[=~+\\-.']+/, '');
}

// å¢ƒç•Œè¨˜å·ã‚’ä¿æŒã—ã¤ã¤æ­£è¦åŒ–ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã®ã¿é™¤å»ï¼‰
function normalizeMorph(text) {
    if (!text) return '';
    return text.replace(/^'+/, '').toLowerCase();
}

// è¦‹å‡ºã—èªã‚»ãƒƒãƒˆã‚’æ§‹ç¯‰ï¼ˆç•°å½¢æ…‹ãƒªãƒ³ã‚¯ç”¨ï¼‰- å¢ƒç•Œè¨˜å·ã‚’ä¿æŒ
const headwordSet = new Set(dictionaryData.map(d => normalizeMorph(d.morph)));

// ç•°å½¢æ…‹ã‚’æ¤œç´¢ã—ã¦ã‚¸ãƒ£ãƒ³ãƒ—
function searchAllomorph(morph) {
    const input = document.getElementById('searchInput');
    // å¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ã¦æ¤œç´¢
    const searchTerm = stripBoundary(morph);
    input.value = searchTerm;
    searchQuery = searchTerm;
    // éƒ¨åˆ†ä¸€è‡´ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆå®Œå…¨ä¸€è‡´ã ã¨è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆãŒã‚ã‚‹ï¼‰
    document.querySelectorAll('.search-option').forEach(o => o.classList.remove('active'));
    document.querySelector('.search-option[data-mode="partial"]').classList.add('active');
    searchMode = 'partial';
    // å½¢æ…‹ç´ ã®ã¿æ¤œç´¢å¯¾è±¡ã«
    searchTargets = { morph: true, gloss: false, pos: false, trans: false, allo: false };
    document.querySelectorAll('.search-target').forEach(t => {
        t.classList.toggle('active', t.dataset.target === 'morph');
    });
    render();
    // æœ€åˆã®çµæœã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const firstEntry = document.querySelector('.entry');
    if (firstEntry) firstEntry.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// ç•°å½¢æ…‹ã®HTMLç”Ÿæˆï¼ˆè¦‹å‡ºã—èªã¨ã—ã¦å­˜åœ¨ã™ã‚Œã°ãƒªãƒ³ã‚¯åŒ–ï¼‰- å¢ƒç•Œè¨˜å·ã‚’åŒºåˆ¥
function renderAllomorph(allo) {
    const normalized = normalizeMorph(allo);
    if (headwordSet.has(normalized)) {
        return \`<span class="allomorph-item allomorph-link" onclick="searchAllomorph('\${allo.replace(/'/g, "\\\\'")}')">ğŸ”— \${allo}</span>\`;
    }
    return \`<span class="allomorph-item">\${allo}</span>\`;
}

function renderEntry(item, q) {
    const posClass = getPosClass(item.pos), indexHtml = item.morph_index ? \`<span class="morph-index">\${item.morph_index}</span>\` : '';
    const headerClass = reverseMode ? 'entry-header reverse' : 'entry-header';
    const glossDisplay = reverseMode && item.glosses_all?.length > 1 ? item.glosses_all.join('ã€') : item.gloss;
    let allomorphsHtml = item.allomorphs?.length ? \`<div class="allomorphs">\${item.allomorphs.map(a => renderAllomorph(a)).join('')}</div>\` : '';
    let examplesHtml = '';
    if (item.examples?.length) {
        const tc = item.examples.filter(e => e.trans).length, ac = item.examples.filter(e => e.audio_file).length;
        examplesHtml = \`<div class="examples-section"><div class="examples-title">ğŸ“– ç”¨ä¾‹ \${item.examples.length}ä»¶\${tc ? \`ï¼ˆå’Œè¨³\${tc}ä»¶ï¼‰\` : ''}\${ac ? \` ğŸ”Š\${ac}ä»¶\` : ''}</div>\${item.examples.map(renderExample).join('')}</div>\`;
    }
    return \`<div class="entry"><div class="\${headerClass}"><span class="morph">\${highlightText(item.morph, q)}\${indexHtml}</span><span class="pos-badge \${posClass}">\${item.pos || '?'}</span><span class="gloss-main">\${highlightText(glossDisplay, q)}</span></div>\${allomorphsHtml}\${examplesHtml}</div>\`;
}

function getSortedData() {
    if (reverseMode) {
        const groups = new Map();
        for (const item of dictionaryData) {
            if (!groups.has(item.morph)) groups.set(item.morph, { morph: item.morph, glosses: [], pos: item.pos, allomorphs: new Set(), examples: [] });
            const g = groups.get(item.morph), base = item.gloss?.split('.')[0] || '';
            if (base && !g.glosses.includes(base)) g.glosses.push(base);
            (item.allomorphs || []).forEach(a => g.allomorphs.add(a));
            (item.examples || []).forEach(ex => { if (g.examples.length < 3 && !g.examples.some(e => e.text === ex.text)) g.examples.push(ex); });
        }
        return [...groups.values()].map(g => ({ morph: g.morph, gloss: g.glosses.sort((a, b) => getGojuonSortKey(a).localeCompare(getGojuonSortKey(b), 'ja'))[0] || '', glosses_all: g.glosses, pos: g.pos, allomorphs: [...g.allomorphs].sort(), examples: g.examples, morph_index: null })).sort((a, b) => getGojuonSortKey(a.gloss).localeCompare(getGojuonSortKey(b.gloss), 'ja'));
    }
    return [...dictionaryData].sort((a, b) => stripBoundary(a.morph).toLowerCase().localeCompare(stripBoundary(b.morph).toLowerCase()) || (a.pos || '').localeCompare(b.pos || ''));
}

function matchSearch(text, query, mode) {
    if (!text || !query) return false;
    const t = text.toLowerCase();
    const q = query.toLowerCase();
    switch(mode) {
        case 'exact': return t === q;
        case 'prefix': return t.startsWith(q);
        case 'suffix': return t.endsWith(q);
        default: return t.includes(q);
    }
}

// å½¢æ…‹ç´ æ¤œç´¢ç”¨ï¼šå¢ƒç•Œè¨˜å·ã‚’é™¤å»ã—ã¦æ¤œç´¢
function matchMorphSearch(text, query, mode) {
    if (!text || !query) return false;
    const t = stripBoundary(text).toLowerCase();
    const q = query.toLowerCase();
    switch(mode) {
        case 'exact': return t === q;
        case 'prefix': return t.startsWith(q);
        case 'suffix': return t.endsWith(q);
        default: return t.includes(q);
    }
}

function filterData() {
    return getSortedData().filter(item => {
        if (currentLetter) { 
            if (reverseMode) { 
                if (getGojuonRow(item.gloss) !== currentLetter) return false; 
            } else { 
                if (stripBoundary(item.morph).charAt(0).toLowerCase() !== currentLetter.toLowerCase()) return false; 
            } 
        }
        if (currentFilter && item.pos !== currentFilter) return false;
        if (searchQuery) {
            let match = false;
            if (searchTargets.morph && matchMorphSearch(item.morph, searchQuery, searchMode)) match = true;
            if (!match && searchTargets.gloss) {
                if (reverseMode && item.glosses_all) {
                    if (item.glosses_all.some(g => matchSearch(g, searchQuery, searchMode))) match = true;
                } else if (matchSearch(item.gloss, searchQuery, searchMode)) match = true;
            }
            if (!match && searchTargets.pos && matchSearch(item.pos, searchQuery, searchMode)) match = true;
            if (!match && searchTargets.allo && item.allomorphs?.some(a => matchMorphSearch(a, searchQuery, searchMode))) match = true;
            if (!match && searchTargets.trans && item.examples?.some(ex => matchSearch(ex.trans, searchQuery, searchMode))) match = true;
            if (!match) return false;
        }
        return true;
    });
}

function render() {
    const list = document.getElementById('dictionaryList'), stats = document.getElementById('stats');
    const filtered = filterData();
    list.innerHTML = filtered.length === 0 ? '<div class="no-results">è©²å½“ã™ã‚‹èªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>' : filtered.map(item => renderEntry(item, searchQuery)).join('');
    const exCount = filtered.reduce((s, i) => s + (i.examples?.length || 0), 0), transCount = filtered.reduce((s, i) => s + (i.examples?.filter(e => e.trans).length || 0), 0), audioCount = filtered.reduce((s, i) => s + (i.examples?.filter(e => e.audio_file).length || 0), 0);
    stats.textContent = \`\${reverseMode ? 'ã€é€†å¼•ãã€‘' : 'ã€è¦‹å‡ºã—é †ã€‘'} è¡¨ç¤º: \${filtered.length}èªï¼ˆç”¨ä¾‹: \${exCount}ä»¶ã€å’Œè¨³: \${transCount}ä»¶ã€éŸ³å£°: \${audioCount}ä»¶ï¼‰\`;
}

function initAlphabetNav() {
    const nav = document.getElementById('alphabetNav'); nav.innerHTML = '';
    const allBtn = document.createElement('button'); allBtn.textContent = 'å…¨ã¦'; allBtn.className = 'active';
    allBtn.onclick = () => { currentLetter = null; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); allBtn.classList.add('active'); render(); };
    nav.appendChild(allBtn);
    if (reverseMode) {
        const used = new Set(dictionaryData.map(d => getGojuonRow(d.gloss)));
        gojuonRows.forEach(row => { if (used.has(row.label)) { const btn = document.createElement('button'); btn.textContent = row.label + 'è¡Œ'; btn.onclick = () => { currentLetter = row.label; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; nav.appendChild(btn); } });
    } else {
        [...new Set(dictionaryData.map(d => stripBoundary(d.morph).charAt(0).toLowerCase()))].sort().forEach(letter => { const btn = document.createElement('button'); btn.textContent = letter.toUpperCase(); btn.onclick = () => { currentLetter = letter; nav.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; nav.appendChild(btn); });
    }
}

function initPosFilters() {
    const allPos = new Set(dictionaryData.map(d => d.pos).filter(Boolean)), filters = document.getElementById('posFilters'); filters.innerHTML = '';
    const allBtn = document.createElement('button'); allBtn.className = 'filter-btn active'; allBtn.textContent = 'å…¨å“è©';
    allBtn.onclick = () => { currentFilter = null; filters.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active')); allBtn.classList.add('active'); render(); };
    filters.appendChild(allBtn);
    ['V','N','ADJ','ADV','AUX','PRN','CP','ISP','SFP','INTJ','CONJ','VAFX','NAFX','FN','PN','CJP','LP'].forEach(pos => { if (allPos.has(pos)) { const btn = document.createElement('button'); btn.className = 'filter-btn'; btn.textContent = pos; btn.onclick = () => { currentFilter = pos; filters.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); render(); }; filters.appendChild(btn); } });
}

document.getElementById('modeNormal').onclick = () => { reverseMode = false; document.getElementById('modeNormal').classList.add('active'); document.getElementById('modeReverse').classList.remove('active'); currentLetter = null; initAlphabetNav(); render(); };
document.getElementById('modeReverse').onclick = () => { reverseMode = true; document.getElementById('modeReverse').classList.add('active'); document.getElementById('modeNormal').classList.remove('active'); currentLetter = null; initAlphabetNav(); render(); };
document.getElementById('searchInput').oninput = (e) => { searchQuery = e.target.value; render(); };

// æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
document.querySelectorAll('.search-option').forEach(function(opt) {
    opt.onclick = function() {
        document.querySelectorAll('.search-option').forEach(function(o) { o.classList.remove('active'); });
        opt.classList.add('active');
        searchMode = opt.dataset.mode;
        if (searchQuery) render();
    };
});

// æ¤œç´¢å¯¾è±¡åˆ‡æ›¿
document.querySelectorAll('.search-target').forEach(function(tgt) {
    tgt.onclick = function() {
        tgt.classList.toggle('active');
        searchTargets[tgt.dataset.target] = tgt.classList.contains('active');
        if (searchQuery) render();
    };
});

document.getElementById('totalCount').textContent = dictionaryData.length;
initAlphabetNav(); initPosFilters(); render();

function downloadCSV() {
    const escapeCSV = (str) => {
        if (!str) return '';
        str = String(str);
        // Excelã§æ•°å¼ã¨ã—ã¦è§£é‡ˆã•ã‚Œã‚‹è¨˜å·ã§å§‹ã¾ã‚‹å ´åˆã€å…ˆé ­ã«ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’ä»˜ã‘ã‚‹
        if (/^[=+\-@]/.test(str)) {
            str = "'" + str;
        }
        if (str.includes(',') || str.includes('"') || str.includes('\\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    };
    
    // ãƒ˜ãƒƒãƒ€ãƒ¼
    const headers = ['morph', 'pos', 'gloss', 'allomorphs', 'morph_index', 'ex_text', 'ex_trans', 'ex_morphs', 'ex_glosses', 'ex_audio', 'ex_start', 'ex_end', 'ex_target'];
    let csv = headers.join(',') + '\\n';
    
    for (const entry of dictionaryData) {
        const base = [
            escapeCSV(entry.morph),
            escapeCSV(entry.pos),
            escapeCSV(entry.gloss),
            escapeCSV((entry.allomorphs || []).join('|')),
            escapeCSV(entry.morph_index || '')
        ];
        
        if (entry.examples && entry.examples.length > 0) {
            for (const ex of entry.examples) {
                const row = [
                    ...base,
                    escapeCSV(ex.text),
                    escapeCSV(ex.trans),
                    escapeCSV((ex.morphs || []).join('|')),
                    escapeCSV((ex.glosses || []).join('|')),
                    escapeCSV(ex.audio_file),
                    escapeCSV(ex.start_time),
                    escapeCSV(ex.end_time),
                    ex.target_index !== undefined ? String(ex.target_index) : ''
                ];
                csv += row.join(',') + '\\n';
            }
        } else {
            csv += base.join(',') + ',,,,,,,,' + '\\n';
        }
    }
    
    const bom = '\\uFEFF';
    const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'dictionary.csv';
    a.click();
    URL.revokeObjectURL(url);
}
<\/script>
</body>
</html>`;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// Event Handlers
// ============================================================================

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.onclick = () => fileInput.click();
dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
dropZone.ondragleave = () => dropZone.classList.remove('dragover');
dropZone.ondrop = (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
};

fileInput.onchange = (e) => handleFiles(e.target.files);

function handleFiles(files) {
    for (const file of files) {
        const reader = new FileReader();
        reader.onload = (e) => handleFile(file, e.target.result);
        reader.readAsText(file);
    }
    fileInput.value = '';
}

document.getElementById('btnGenerate').onclick = generateHTML;
document.getElementById('btnReloadTxt').onclick = reloadWithTxtLayerConfig;
</script>
</body>
</html>
